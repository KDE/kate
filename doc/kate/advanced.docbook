<chapter id="advanced-editing-tools">
<chapterinfo>
<authorgroup>
<author>&Anders.Lund; &Anders.Lund.mail;</author>
<author>&Dominik.Haumann; &Dominik.Haumann.mail;</author>
<!-- TRANS:ROLES_OF_TRANSLATORS -->
</authorgroup>
</chapterinfo>
<title>Advanced Editing Tools</title>

<sect1 id="advanced-editing-tools-comment">

<title>Comment/Uncomment</title>

<para>The Comment and Uncomment commands, available from the
<guimenu>Tools</guimenu> menu allow you to add or remove comment
markers to the selection, or the current line if no text is selected,
if comments are supported by the format of the text you are
editing.</para>

<para>The rules for how commenting is done are defined in the syntax
definitions, so if syntax highlighting is not used, commenting/uncommenting
is not possible. </para>

<para>Some formats define single line comment markers, some multiline
markers and some both.  If multiline markers are not available,
commenting out a selection that does not fully include its last line
is not possible.</para>

<para>If a single line marker is available, commenting single lines is
preferred where applicable, as this helps to avoid problems with
nested comments.</para>

<para>When removing comment markers, no uncommented text should be
selected. When removing multiline comment markers from a selection,
any whitespace outside the comment markers is ignored.</para>

<para><indexterm><primary>comment</primary></indexterm>
To place comment markers, use the
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Comment</guimenuitem></menuchoice>
menu item or the related keyboard shortcut sequence, default is
<keycombo action="simul">&Ctrl;<keycap>D</keycap></keycombo>.</para>

<para><indexterm><primary>uncomment</primary></indexterm>
To remove comment markers, use the
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Uncomment</guimenuitem></menuchoice>
menu item or the related keyboard shortcut, default is <keycombo
action="simul">&Ctrl;&Shift;<keycap>D</keycap></keycombo>.</para>

</sect1>

<sect1 id="advanced-editing-tools-commandline">
<title>The Editor Component Command Line</title>

<para>&kate;'s editor component has an internal command line, allowing you to
perform various actions from a minimal GUI. The command line is a text entry
in the bottom of the editor area, to show it select
<menuchoice><guimenu>View</guimenu><guimenuitem>Switch to Command Line</guimenuitem></menuchoice>
or use the shortcut (default is
<keycombo action="simul"><keycap>F7</keycap></keycombo>). The editor provides
a set of commands as documented below, and additional commands can be provided
by plugins.</para>

<para>To execute a command, type the command then press the return key. The
command line will indicate whether it succeeded and possibly display a message. If
you entered the command line by pressing <keycap>F7</keycap> it will
automatically hide after a few seconds. To clear the message and enter a new
command, press <keycap>F7</keycap> again.</para>

<para>The command line has a built-in help system, issue the command
<command>help</command> to get started. To see a list of all available commands
issue <command>help list</command>, to view help for a specific command, do
<command>help <replaceable>command</replaceable></command>.</para>

<para>The command line has a built in history, so you can reuse commands already
typed. To navigate the history, use the <keycap>Up</keycap> and
<keycap>Down</keycap> keys. When showing historical commands, the argument part
of the command will be selected, allowing you to easily overwrite the
arguments.</para>

<sect2 id="advanced-editing-tools-commandline-commands">
<title>Standard Command Line Commands</title>

<sect3 id="advanced-editing-tools-commandline-commands-configure">
<title>Commands for Configuring the Editor</title>

<para>These commands are provided by the editor component, and allows you to
configure the active document and view only. This is handy if you want to use
a setting different from the default settings, for example for indentation.
</para>

<variablelist>
<title>Argument types</title>

<varlistentry>
<term>BOOLEAN</term>
<listitem><para>This is used with commands that turns things on or off.
Legal values are <userinput>on</userinput>, <userinput>off</userinput>,
<userinput>true</userinput>, <userinput>false</userinput>,
<userinput>1</userinput> or <userinput>0</userinput></para></listitem>
</varlistentry>

<varlistentry>
<term>INTEGER</term>
<listitem><para>An integer number</para></listitem>
</varlistentry>

<varlistentry>
<term>STRING</term>
<listitem><para>A string</para></listitem>
</varlistentry>

</variablelist>

<variablelist>

<varlistentry>
<term><cmdsynopsis><command>set-tab-width</command><arg>INTEGER width</arg></cmdsynopsis></term>
<listitem><para>Sets the tab width to the number <userinput>width</userinput></para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-indent-width</command><arg>INTEGER width</arg></cmdsynopsis></term>
<listitem><para>Sets the indentation width to the number
<userinput>width</userinput>. Used only if you are indenting with
spaces.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-word-wrap-column</command><arg>INTEGER width</arg></cmdsynopsis></term>
<listitem><para>Sets the line width for hard wrapping to
<userinput>width</userinput>. This is used if you are having your text wrapped
automatically.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-icon-border</command><arg>BOOLEAN enable</arg>
</cmdsynopsis></term>
<listitem><para>Sets the visibility of the icon border.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-folding-markers</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>Sets the visibility of the folding markers pane.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-line-numbers</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>Sets the visibility of the line numbers pane.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-replace-tabs</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>If enabled, tabs are replaced with spaces as you type.
</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-remove-trailing-space</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>If enabled, trailing whitespace are removed whenever the cursor
leaves a line.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-show-tabs</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>If enabled, TAB characters and trailing whitespace will be
visualized by a small dot.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-indent-spaces</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>If enabled, the editor will indent with
<option>indent-width</option> spaces for each indentation level, rather than
with one TAB character.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-mixed-indent</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>If enabled, &kate; will use a mix of TAB and spaces for
indentation. Each indentation level will be <option>indent-width</option> wide,
and more indentation levels will be optimized to use as many TAB characters as
possible.</para>
<para>When executed, this command will additionally set space indentation enabled,
and if the indent width is unspecified it will be set to half of the
<option>tab-width</option> for the document at the time of execution.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-word-wrap</command><arg>BOOLEAN
enable</arg></cmdsynopsis></term>
<listitem><para>Enables dynamic word wrap according to
<userinput>enable</userinput></para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-replace-tabs-save</command><arg>BOOLEAN enable
</arg></cmdsynopsis></term>
<listitem><para>When enabled, tabs will be replaced with whitespace whenever
 the document is saved.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-remove-trailing-space-save</command><arg>BOOLEAN enable</arg></cmdsynopsis></term>
<listitem><para>When enabled, trailing space will be removed from each line
whenever the document is saved.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-indent-mode</command><arg>name</arg></cmdsynopsis></term>
<listitem><para>Sets the autoindentation mode to <userinput>name</userinput>.
If <userinput>name</userinput> is not known, the mode is set to 'none'. Valid
modes are 'none', 'normal', 'cstyle', 'haskell', 'lilypond', 'lisp', 'python',
'ruby' and 'xml'.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>set-highlight</command><arg>highlight</arg></cmdsynopsis></term>
<listitem><para>Sets the syntax highlighting system for the document. The
argument must be a valid highlight name, as seen in the
<menuchoice><guimenu>Tools</guimenu><guisubmenu>Highlighting</guisubmenu></menuchoice>
menu. This command provides an autocompletion list for its
argument.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3 id="advanced-editing-tools-commandline-commands-edit">
<title>Commands for editing</title>

<para>These commands modify the current document.</para>

<variablelist>
<varlistentry>
<term><cmdsynopsis><command>indent</command></cmdsynopsis></term>
<listitem><para>Indents the selected lines or the current line.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>unindent</command></cmdsynopsis></term>
<listitem><para>Unindents the selected lines or current line.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>cleanindent</command></cmdsynopsis></term>
<listitem><para>Cleans up the indentation of the selected lines or current line
according to the indentation settings in the document.
</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>comment</command></cmdsynopsis></term>
<listitem><para>Inserts comment markers to make the selection or selected lines
or current line a comment according to the text format as defined by the syntax
highlight definition for the document.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>uncomment</command></cmdsynopsis></term>
<listitem><para>Removes comment markers from the selection or selected lines
or current line according to the text format as defined by the syntax highlight
definition for the document.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>kill-line</command></cmdsynopsis></term>
<listitem><para>Deletes the current line.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>replace</command><arg>pattern</arg><arg>replacement</arg></cmdsynopsis></term>
<listitem><para>Replaces text matching <userinput>pattern</userinput> with
<userinput>replacement</userinput>. If you want to include whitespace in the
<userinput>pattern</userinput>, you must quote both the <userinput>pattern</userinput>
and <userinput>replacement</userinput> with single or double quotes. If the
arguments are unquoted, the first word is used as <userinput>pattern</userinput>
and the rest for <userinput>replacement</userinput>. If
<userinput>replacement</userinput> is empty, each occurrence of
<userinput>pattern</userinput> is removed.</para>
<para>You can set flags to configure the search by adding a colon, followed
by one or more letters each representing a configuration, giving the form
<userinput>replace:options pattern replacement</userinput>. Available options
are:

<variablelist>

<varlistentry>
<term><userinput>b</userinput></term>
<listitem><para>Search backwards.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>c</userinput></term>
<listitem><para>Search from cursor position.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>e</userinput></term>
<listitem><para>Search in the selection only.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>r</userinput></term>
<listitem><para>Do regular expression search. If set, you may use
<userinput>\N</userinput> where N is a number to represent captures in the
replacement string.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>s</userinput></term>
<listitem><para>Do case sensitive search.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>p</userinput></term>
<listitem><para>Prompt for permission to replace the next occurrence.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>w</userinput></term>
<listitem><para>Match whole words only.</para></listitem>
</varlistentry>

</variablelist>

</para>
</listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>date</command><arg>format</arg></cmdsynopsis></term>
<listitem><para>Inserts a date/time string as defined by the specified
<userinput>format</userinput>, or the format <quote>yyyy-MM-dd hh:mm:ss</quote>
if none is specified. The following translations are done when interpreting
<userinput>format</userinput>:

<informaltable>
<tgroup cols="2">
<tbody>
<row><entry><literal>d</literal></entry><entry>The day as number without a leading zero (1-31).</entry></row>
<row><entry><literal>dd</literal></entry><entry>The day as number with a leading zero (01-31).</entry></row>
<row><entry><literal>ddd</literal></entry><entry>The abbreviated localized day name (e.g. 'Mon'..'Sun').</entry></row>
<row><entry><literal>dddd</literal></entry><entry>The long localized day name (e.g. 'Monday'..'Sunday').</entry></row>
<row><entry><literal>M</literal></entry><entry>The month as number without a leading zero (1-12).</entry></row>
<row><entry><literal>MM</literal></entry><entry>The month as number with a leading zero (01-12).</entry></row>
<row><entry><literal>MMM</literal></entry><entry>The abbreviated localized month name (e.g. 'Jan'..'Dec').</entry></row>
<row><entry><literal>yy</literal></entry><entry>The year as two digit number
(00-99).</entry></row>
<row><entry><literal>yyyy</literal></entry><entry>The year as four digit number (1752-8000).</entry></row>
<row><entry><literal>h</literal></entry><entry>The hour without a leading zero (0..23 or 1..12 if AM/PM display).</entry></row>
<row><entry><literal>hh</literal></entry><entry>The hour with a leading zero (00..23 or 01..12 if AM/PM display).</entry></row>
<row><entry><literal>m</literal></entry><entry>The minute without a leading zero (0..59).</entry></row>
<row><entry><literal>mm</literal></entry><entry>The minute with a leading zero (00..59).</entry></row>
<row><entry><literal>s</literal></entry><entry>The second without a leading zero (0..59).</entry></row>
<row><entry><literal>ss</literal></entry><entry>The second with a leading zero (00..59).</entry></row>
<row><entry><literal>z</literal></entry><entry>The milliseconds without leading zeroes (0..999).</entry></row>
<row><entry><literal>zzz</literal></entry><entry>The milliseconds with leading zeroes (000..999).</entry></row>
<row><entry><literal>AP</literal></entry><entry>Use AM/PM display. AP will be replaced by either "AM" or "PM".</entry></row>
<row><entry><literal>ap</literal></entry><entry>Use am/pm display. ap will be replaced by either "am" or "pm".</entry></row>

</tbody>
</tgroup>
</informaltable>

</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>char</command><arg>identifier</arg></cmdsynopsis></term>
<listitem>
<para>This command allows you to insert literal characters by their
numerical identifier, in decimal, octal or hexadecimal form.
To use it launch the Editing Command dialog and type <userinput>char:
[number]</userinput> in the entry box, then hit
<guibutton>OK</guibutton>.</para>

<example>
<title><command>char</command> examples</title>

<para>Input: <userinput>char:234</userinput></para>
<para>Output: <computeroutput>&#234;</computeroutput></para>
<para>Input: <userinput>char:0x1234</userinput></para>
<para>Output: <computeroutput>&#x1234;</computeroutput></para>
</example>

</listitem>
</varlistentry>

<varlistentry>
<term>
<indexterm><primary>replace, sed style</primary>
<secondary>search, sed style</secondary></indexterm>
<command>s///[ig]</command> <command>%s///[ig]</command></term>

<listitem>
<para>This command does a sed-like search/replace operation on the
current line, or on the whole file (<command>%s///</command>).</para>

<para>In short, the text is searched for text matching the
<emphasis>search pattern</emphasis>, the regular expression between
the first and the second slash, and when a match is found, the
matching part of the text is replaced with the expression between the
middle and last part of the string. Parentheses in the search pattern
create <emphasis>back references</emphasis>, that is the command
remembers which part of the match matched in the parentheses; these
strings can be reused in the replace pattern, referred to as
<userinput>\1</userinput> for the first set of parentheses,
<userinput>\2</userinput> for the second and so on.</para>

<para>To search for a literal <literal>(</literal> or
<literal>)</literal>, you need to <emphasis>escape</emphasis> it using
a backslash character: <userinput>\(\)</userinput></para>

<para>If you put an <userinput>i</userinput> at the end of the
expression, the matching will be case insensitive. If you put a
<userinput>g</userinput> at the end, all occurrences of the pattern will be
replaced, otherwise only the first occurrence is replaced.</para>

<example>

<title>Replacing text in the current line</title>

<para>Your friendly compiler just stopped, telling you that the class
<classname>myClass</classname> mentioned in line 3902 in your source file
is not defined.</para>

<para>&quot;Buckle!&quot; you think, it is of course
<classname>MyClass</classname>. You go to line 3902, and instead of trying
to find the word in the text, you launch the Editing Command Dialog,
enter <userinput>s/myclass/MyClass/i</userinput>, hit the
<guibutton>OK</guibutton> button, save the file and compile &ndash;
successfully without the error.</para>

</example>

<example>
<title>Replacing text in the whole file</title>

<para>Imagine that you have a file, in which you mention a <quote>Miss
Jensen</quote> several times, when someone comes in and tells you that
she just got married to <quote>Mr Jones</quote>. You want, of course,
to replace each and every occurrence of <quote>Miss Jensen</quote>
with <quote>Ms Jones</quote>.</para>

<para>Enter the command line and issue the command
<userinput>%s/Miss Jensen/Ms Jones/</userinput> and hit return, you
are done.</para>

</example>

<example>
<title>A More Advanced Example</title>

<para>This example makes use of <emphasis>back references</emphasis>
as well as a <emphasis>character class</emphasis> (if you do not know what
that is, please refer to the related documentation mentioned
below).</para>

<para>Suppose you have the following line:

<programlisting>void MyClass::DoStringOps( String      &amp;foo, String &amp;bar String *p, int  &amp;a, int &amp;b )</programlisting>
</para>
<para>Now you realize that this is not nice code, and decide that you
want to use the <constant>const</constant> keyword for all
<quote>address of</quote> arguments, those characterized by the &amp;
operator in front of the argument name. You would also like to
simplify the white space, so that there is only 1 whitespace character
between each word.</para>

<para>Launch the Editing Command Dialog, and enter:
<userinput>s/\s+(\w+)\s+(&amp;)/ const \1 \2/g</userinput> and hit the
<guibutton>OK</guibutton> button. The <userinput>g</userinput> at the end of the expression makes
the regular expression recompile for each match to save the <emphasis>backreferences</emphasis>.</para>

<para>Output:

<computeroutput>void MyClass::DoStringOps( const String &amp;foo, const String &amp;bar String *p, const int &amp;a, const int &amp;b )</computeroutput></para>

<para>Mission completed! Now, what happened? Well, we looked for some
white space (<literal>\s+</literal>) followed by one or more
alphabetic characters (<literal>\w+</literal>) followed by some more
whitespace (<literal>\s+</literal>) followed by an ampersand, and in
the process saved the alphabetic chunk and the ampersand for reuse in
the replace operation. Then we replaced the matching part of our line
with one whitespace followed by <quote>const</quote> followed by one
whitespace followed by our saved alphabetical chunk
(<literal>\1</literal>) followed by one whitespace followed by our
saved ampersand (<literal>\2</literal>)</para>

<para>Now in some cases the alphabetical chunk was
<quote>String</quote>, in some <quote>int</quote>, so using the
character class <literal>\w</literal> and the <literal>+</literal>
quantifier proved a valuable asset.</para>

</example>

</listitem>

</varlistentry>

</variablelist>

</sect3>

<sect3 id="advanced-editing-tools-commandline-commands-navigation">
<title>Commands for navigation</title>

<variablelist>

<varlistentry>
<term><cmdsynopsis><command>goto</command><arg>INT line</arg></cmdsynopsis></term>
<listitem><para>This command navigates to the specified line.</para></listitem>
</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>find</command><arg>pattern</arg></cmdsynopsis></term>
<listitem><para>This command navigates to the first occurrence of
<userinput>pattern</userinput> according to the configuration. Following
occurrences can be found using
<menuchoice><guimenu>Edit</guimenu><guimenuitem>Find Next</guimenuitem></menuchoice>
(the default shortcut is <keycap>F3</keycap>).</para>
<para>The find command can be configured by appending a colon followed by one or
more options, the form is
<userinput>find:options pattern</userinput>. The
following options are supported:

<variablelist>

<varlistentry>
<term><userinput>b</userinput></term>
<listitem><para>Search backwards.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>c</userinput></term>
<listitem><para>Search from cursor position.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>e</userinput></term>
<listitem><para>Search in the selection only.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>r</userinput></term>
<listitem><para>Do regular expression search. If set, you may use
<userinput>\N</userinput> where N is a number to represent captures in the
replacement string.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>s</userinput></term>
<listitem><para>Do case sensitive search.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>w</userinput></term>
<listitem><para>Match whole words only.</para></listitem>
</varlistentry>

</variablelist>

</para>

</listitem>

</varlistentry>

<varlistentry>
<term><cmdsynopsis><command>ifind</command><arg>pattern</arg></cmdsynopsis></term>
<listitem><para>This command provides <quote>as-you-type</quote> searching. You
can configure the behavior of the search by appending a colon
followed by one or more options, like this:
<userinput>ifind:options pattern</userinput>. Allowed options are

<variablelist>
<varlistentry>
<term><userinput>b</userinput></term>
<listitem><para>Search backwards.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>r</userinput></term>
<listitem><para>Do regular expression search.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>s</userinput></term>
<listitem><para>Do case sensitive search.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>c</userinput></term>
<listitem><para>Search from cursor position.</para></listitem>
</varlistentry>

</variablelist>
</para></listitem>
</varlistentry>

</variablelist>

</sect3>

</sect2>

</sect1>

<sect1 id="advanced-editing-tools-code-folding">
<title>Using Code Folding</title>

<para>Code folding allows you to hide parts of a document in the editor, making
it easier to overview large documents. In &kate; the foldable regions are
calculated using rules defined in the syntax highlight definitions, and
therefore it is only available in some formats - typically program source code,
XML markup and similar. Most highlight definitions supporting code folding
also lets you manually define foldable regions, typically using the
<userinput>BEGIN</userinput> and <userinput>END</userinput> keywords.</para>

<para>To use the code folding feature, activate the folding markers using
<menuchoice><guimenu>View</guimenu><guimenuitem>Show Folding
Markers</guimenuitem></menuchoice> menu item if they are not already visible.
The Folding Markers Pane in the left side of the screen displays a graphical
view of the foldable regions, with triangle symbols to indicate the possible operation
on a given region: a top down triangle means that the region is expanded, clicking it will
collapse the region and a right pointing triangle will be displayed instead.</para>

<para>Four commands are provided to manipulate the state of folding regions,
see the <link linkend="view-code-folding">menu documentation</link>.
</para>

<para>If you do not want to use the code folding feature, you can disable
the <guilabel>Show folding markers (if available)</guilabel> option in the
<link linkend="appearance">Appearance</link> page of the editor
configuration.</para>

</sect1>

<sect1 id="advanced-editing-tools-scripting">
<title>Extending &kate; with Scripts</title>

<para>
Since &kate; 3.4 in KDE 4.4 the &kate; editor component is easily extensible by
writing scripts. The scripting language is ECMAScript (widely known as JavaScript).
&kate; supports two kinds of scripts: indentation and command line scripts.
</para>

<sect2 id="advanced-editing-tools-scripting-indentation">
<title>Indentation Scripts</title>

<para>
Indentation scripts - also referred as indenters - automatically indent the
source code while typing text. As example, after hitting the return-key code
the indentation level often increases.
</para>

<para>
The following sections describe step by step how to create the skeleton for a
simple indenter. As first step, create a new <filename>*.js</filename> file
called e.g. <filename>javascript.js</filename> in the local home folder
<filename>$KDEHOME/share/apps/katepart/script</filename>.
</para>

<sect3 id="advanced-editing-tools-scripting-indentation-header">
<title>The Indentation Script Header</title>
<para>
The header of the file <filename>javascript.js</filename> is embedded in a
comment and is of the following form

<programlisting>
/* kate-script
 * name: JavaScript
 * author: Example Name &lt;example.name@some.address.org&gt;
 * license: BSD
 * revision: 1
 * kate-version: 3.4
 * type: indentation
 * required-syntax-style: javascript
 * indent-languages: javascript
 * priority: 0
 * i18n-catalog: mycatalog
 *
 * A line without colon ':' stops header parsing. That is, you can add optional
 * text here such as a detailed license.
 */
</programlisting>

Each entry is explained in detail now:
<itemizedlist>
<listitem><para>
<literal>kate-script</literal> [required]: This text string has to appear in the first line of the <filename>*.js</filename> file, otherwise &kate; skips the script.
</para></listitem>
<listitem><para>
<literal>name</literal> [required]: This is the indenter name that appears in the menu
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Indentation</guimenuitem></menuchoice>
and in the configuration dialog.
</para></listitem>
<listitem><para>
<literal>author</literal> [optional]: The author's name and contact information.
</para></listitem>
<listitem><para>
<literal>license</literal> [optional]: Short form of the license, such as BSD or LGPLv3.
</para></listitem>
<listitem><para>
<literal>revision</literal> [required]: The revision of the script. This number should be increased whenever the script is modified.
</para></listitem>
<listitem><para>
<literal>kate-version</literal> [required]: Minimal required &kate; version.
</para></listitem>
<listitem><para>
<literal>type</literal> [required]: The type must be <quote><literal>indentation</literal></quote>, otherwise &kate; skips this script.
</para></listitem>
<listitem><para>
<literal>required-syntax-style</literal> [optional]: Comma separated list of required syntax highlighting styles. This is important for indenters that rely on specific highlight information in the document. If a required syntax style is specified, the indenter is available only when the appropriate highlighter is active. This prevents <quote>undefined behavior</quote> caused by using the indenter without the expected highlighting schema. For instance, the Ruby indenter makes use of this in the files <filename>ruby.js</filename> and <filename>ruby.xml</filename>.
</para></listitem>
<listitem><para>
<literal>indent-languages</literal> [optional]: Comma separated list of syntax styles the indenter can indent correctly, e.g.: c++, java.
</para></listitem>
<listitem><para>
<literal>priority</literal> [optional]: If several indenters are suited for a certain highlighted file, the priority decides which indenter is chosen as default indenter.
</para></listitem>
<listitem><para><literal>i18n-catalog</literal> [optional]: Additional message catalog (<literal>po</literal> file) loaded for translation of 3rd-party indenters.</para></listitem>
</itemizedlist>
</para>

<para>
&kate; reads all pairs of the form
<quote><replaceable>key</replaceable>:<replaceable>value</replaceable></quote>
until it cannot find a colon anymore. This implies that the header can contain
arbitrary text such as a license as shown in the example.
</para>

</sect3>

<sect3 id="advanced-editing-tools-scripting-indentation-body">
<title>The Indenter Source Code</title>
<para>
Having specified the header this section explains how the indentation scripting
itself works. The basic skeleton of the body looks like this:

<programlisting>
triggerCharacters = "{}/:;";
function indent(line, indentWidth, ch)
{
    // called for each newline (ch == '\n') and all characters specified in
    // the global variable triggerCharacters. When calling <menuchoice><guimenu>Tools</guimenu><guimenuitem>Align</guimenuitem></menuchoice>
    // the variable ch is empty, i.e. ch == ''.
    //
    // see also: Scripting API
    return -2;
}
</programlisting>

The function <function>indent()</function> has three parameters:
<itemizedlist>
<listitem><para><literal>line</literal>: the line that has to be indented</para></listitem>
<listitem><para><literal>indentWidth</literal>: the indentation width in amount of spaces</para></listitem>
<listitem><para><literal>ch</literal>: either a newline character (<literal>ch == '\n'</literal>), the trigger character specified in <literal>triggerCharacters</literal> or empty if the user invoked the action <menuchoice><guimenu>Tools</guimenu><guimenuitem>Align</guimenuitem></menuchoice>.</para></listitem>
</itemizedlist>
The return value of the <function>indent()</function> function specifies how
the line will be indented. If the return value is a simple integer number, it
is interpreted as follows:
<itemizedlist>
<listitem><para>return value <literal>-2</literal>: do nothing</para></listitem>
<listitem><para>return value <literal>-1</literal>: keep indentation (searches for previous non-blank line)</para></listitem>
<listitem><para>return value <literal> 0</literal>: numbers &gt;= 0 specify the indentation depth in spaces</para></listitem>
</itemizedlist>
Alternatively, an array of two elements can be returned:
<itemizedlist>
<listitem><para><literal>return [ indent, align ];</literal></para></listitem>
</itemizedlist>
In this case, the first element is the indentation depth like above with the
same meaning of the special values. However, the second element is an absolute
value representing a column for <quote>alignment</quote>. If this value is higher than the
indent value, the difference represents a number of spaces to be added after
the indentation of the first parameter. Otherwise, the second number is ignored.
Using tabs and spaces for indentation is often referred to as <quote>mixed mode</quote>.
</para>

<para>
Consider the following example: Assume using tabs to indent, and tab width is set
to 4. Here, &lt;tab&gt; represents a tab and '.' a space:
<programlisting>
1: &lt;tab&gt;&lt;tab&gt;foobar("hello",
2: &lt;tab&gt;&lt;tab&gt;......."world");
</programlisting>
When indenting line 2, the <function>indent()</function> function returns [8, 15]. As result, two
tabs are inserted to indent to column 8, and 7 spaces are added to align the
second parameter under the first, so that it stays aligned if the file is viewed
with a different tab width.
</para>

<para>
A default KDE installation ships &kate; with several indenters. The
corresponding JavaScript source code can be found in <filename>$KDEDIR/share/apps/katepart/script</filename>.
</para>

<para>
Developing an indenter requires to reload the scripts to see whether the changes
behave appropriately. Instead of restarting the application, simply switch to
the command line and invoke the command <command>reload-scripts</command>.
</para>

<para>
If you develop useful scripts please consider contributing to the &kate; Project
by <ulink url="mailto:kwrite-devel@kde.org">contacting the mailing list</ulink>.
</para>

</sect3>
</sect2>

<sect2 id="advanced-editing-tools-scripting-command-line">
<title>Command Line Scripts</title>

<para>
As it is hard to satisfy everyone's needs, &kate; supports little helper tools
for quick text manipulation through the
<link linkend="advanced-editing-tools-commandline">built-in command line</link>.
For instance, the command
<command>sort</command> is implemented as script. This section explains how to create
<filename>*.js</filename> files to extend &kate; with arbitrary helper scripts.
</para>

<para>
Command line scripts are located in the same folder as indentation scripts.
So as first step, create a new <filename>*.js</filename> file called
<filename>myutils.js</filename> in the local home folder
<filename>$KDEHOME/share/apps/katepart/script</filename>.
</para>

<sect3 id="advanced-editing-tools-scripting-command-line-header">
<title>The Command Line Script Header</title>
<para>
The header of each command line script is embedded in a comment and is of the
following form

<programlisting>
/* kate-script
 * author: Example Name &lt;example.name@some.address.org&gt;
 * license: BSD
 * revision: 1
 * kate-version: 3.4
 * type: commands
 * functions: sort, format-paragraph
 * i18n-catalog: mycatalog
 *
 * A line without colon ':' stops header parsing. That is, you can add optional
 * text here such as a detailed license.
 */
</programlisting>

Each entry is explained in detail now:
<itemizedlist>
<listitem><para><literal>kate-script</literal> [required]: This text string has to appear in the first line of the <filename>*.js</filename> file, otherwise &kate; skips the script.</para></listitem>
<listitem><para><literal>author</literal> [optional]: The author's name and contact information.</para></listitem>
<listitem><para><literal>license</literal> [optional]: Short form of the license, such as BSD or LGPLv3.</para></listitem>
<listitem><para><literal>revision</literal> [required]: The revision of the script. This number should be increased whenever the script is modified.</para></listitem>
<listitem><para><literal>kate-version</literal> [required]: Minimal required &kate; version.</para></listitem>
<listitem><para><literal>type</literal> [required]: The type must be <quote><literal>commands</literal></quote>, otherwise &kate; skips this script.</para></listitem>
<listitem><para><literal>functions</literal> [required]: Comma separated list of commands in the script.</para></listitem>
<listitem><para><literal>i18n-catalog</literal> [optional]: Additional message catalog (<literal>po</literal> file) loaded for translation of 3rd-party scripts.</para></listitem>
</itemizedlist>
</para>

<para>
&kate; reads all pairs of the form
<quote><replaceable>key</replaceable>:<replaceable>value</replaceable></quote>
until it cannot find a colon
anymore. This implies that the header can contain arbitrary text such as a license
as shown in the example. The value of the key functions is a comma separated list
of command line commands. This means a single script contains an arbitrary amount
of command line commands. Each function is available through &kate;'s
<link linkend="advanced-editing-tools-commandline">built-in command line</link>.
</para>
</sect3>

<sect3 id="advanced-editing-tools-scripting-command-line-body">
<title>The Script Source Code</title>

<para>
All functions specified in the header have to be implemented in the script.
For instance, the script file from the example above needs to implement the two
functions <command>sort</command> and <command>format-paragraph</command>.
All functions have the following syntax:

<programlisting>
function &lt;name&gt;(arg1, arg2, ...)
{
    // ... implementation, see also: Scripting API
}
</programlisting>
</para>

<para>
Arguments in the command line are passed to the function as
<parameter>arg1</parameter>, <parameter>arg2</parameter>, etc.
In order to provide documentation for each command, simply implement the
'<function>help</function>' function as follows:

<programlisting>
function help(cmd)
{
    if (cmd == "sort") {
        return i18n("Sort the selected text.");
    } else if (cmd == "...") {
        // ...
    }
}
</programlisting>

Executing <command>help sort</command> in the command line then calls this help function with
the argument <parameter>cmd</parameter> set to the given command, i.e.
<parameter>cmd == "sort"</parameter>. &kate; then presents the returned text as
documentation to the user. Make sure to
<link linkend="advanced-editing-tools-scripting-api-i18n">translate the strings</link>.
</para>

<sect4 id="advanced-editing-tools-scripting-command-line-shortcuts">
<title>Binding Shortcuts</title>
<para>In order to be able to assign shortcuts, the script needs to provide a
function called <literal>action</literal> as follows:
<programlisting>
function action(cmd)
{
    var a = new Object();
    if (cmd == "sort") {
        a.text = i18n("Sort Selected Text");
        a.icon = "";
        a.category = "";
        a.interactive = false;
        a.shortcut = "";
    } else if (cmd == "moveLinesDown") {
        // same for next action
    }
    return a;
}
</programlisting>
The parameter <literal>cmd</literal> of the function specifies the command for
which a shortcut is requested. There are several fields you have to specify in
the returned javascript object:
<itemizedlist>
<listitem><para><literal>a.text</literal> [required]: The text appears in the menu <menuchoice><guimenu>Tools</guimenu> <guisubmenu>Scripts</guisubmenu></menuchoice>. Make sure to use <literal>i18n</literal> for translation.</para></listitem>
<listitem><para><literal>a.icon</literal> [optional]: The icon appears next to the text in the menu. All KDE icon names can be used here.</para></listitem>
<listitem><para><literal>a.category</literal> [optional]: If a category is specified, the script appears in a submenu. Make sure to use <literal>i18n</literal> for translation.</para></listitem>
<listitem><para><literal>a.interactive</literal> [optional]: If the script needs user input, set this to <literal>true</literal>.</para></listitem>
<listitem><para><literal>a.shortcut</literal> [optional]: The shortcut given here is the default shortcut. Example: Ctrl+Alt+t. See the <ulink url="http://doc.qt.nokia.com/latest/qt.html#Key-enum">Qt documentation</ulink> for further details.</para></listitem>
</itemizedlist>
</para>


<para>
Developing a command line script requires to reload the scripts to see whether
the changes behave appropriately. Instead of restarting the application, simply
switch to the command line and invoke the command <command>reload-scripts</command>.
</para>

<para>
If you develop useful scripts please consider contributing to the &kate; Project
by <ulink url="mailto:kwrite-devel@kde.org">contacting the mailing list</ulink>.
</para>

</sect4>
</sect3>
</sect2>

<sect2 id="advanced-editing-tools-scripting-api">
<title>Scripting API</title>

<para>
The scripting API presented here is available in all scripts, i.e. indentation
scripts and command line commands. Before the contents of a script is loaded,
&kate; first adds several prototypes and functions to the scripting context.
This convenience API contains prototypes like text cursors and text ranges and
is located in the folder <filename>$KDEDIR/share/apps/katepart/api</filename>.
There, the file names of each JavaScript file conforms with the following naming
scheme:

<programlisting>
&lt;number&gt;_&lt;name&gt;.js
</programlisting>

The number has two digits and the name is an arbitrary name such as <quote><filename>myutils</filename></quote>.
Through the number &kate; controls the execution order of the API. I.e., the
file called <filename>05_cursor.js</filename> is called before the file
<filename>10_range.js</filename>. (This is similar to the start order of the
runlevel/init system in Linux).
</para>

<para>
To extend the standard scripting API with own functions and prototypes simply
create a new file in the KDE's local configuration folder
<filename>$KDEHOME/share/apps/katepart/api</filename> and make sure it has a
greater number (execution order) than the other <filename>*.js</filename> files
in the global folder <filename>$KDEDIR/share/apps/katepart/api</filename>.
&kate; automatically searches in both folders for <filename>*.js</filename>
files and executes them in the correct order.
</para>

<para>
To extend existing prototypes like <classname>Cursor</classname> or
<classname>Range</classname>, the recommended way is to
<emphasis>not</emphasis> modify the global <filename>*.js</filename> files.
Instead, create a <filename>*.js</filename> file in the local folder that is
being executed later than the <filename>05_cursor.js</filename> and then change
the <classname>Cursor</classname> prototype in JavaScript.
</para>

<sect3 id="advanced-editing-tools-scripting-api-prototypes">
<title>Cursors and Ranges</title>

<para>
As &kate; is a text editor, all the scripting API is based on cursors and
ranges whenever possible. A Cursor is a simple <literal>(line, column)</literal>
tuple representing a text position in the document. A Range spans text from a
starting cursor position to an ending cursor position. The API is explained in
detail in the next sections.
</para>

<sect4 id="advanced-editing-tools-scripting-api-cursors">
<title>The Cursor Prototype</title>

<variablelist><varlistentry>
<term><synopsis>
Cursor();
</synopsis></term>
<listitem><para>
Constructor. Returns a Cursor at position <literal>(0, 0)</literal>.</para>
<para>Example: <function>var cursor = new Cursor();</function>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Cursor(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Returns a Cursor at position (line, column).
</para>
<para>Example: <function>var cursor = new Cursor(3, 42);</function>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Cursor(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Copy constructor. Returns a copy of the cursor <replaceable>other</replaceable>.
</para>
<para>Example: <function>var copy = new Cursor(other);</function>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Cursor Cursor.clone();
</synopsis></term>
<listitem><para>
Returns a clone of the cursor.</para>
<para>Example: <function>var clone = cursor.clone();</function>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Cursor.isValid();
</synopsis></term>
<listitem><para>
Check whether the cursor is valid. The cursor is invalid, if line and/or
column are set to <literal>-1</literal>.
</para>
<para>
Example: <function>var valid = cursor.isValid();</function>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Cursor Cursor.invalid();
</synopsis></term>
<listitem><para>
Returns an new invalid cursor located at <literal>(-1, -1)</literal>.
</para>
<para>Example: <function>var invalidCursor = cursor.invalid();</function>
</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
int Cursor.compareTo(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Compares this cursor to the cursor <replaceable>other</replaceable>. Returns
<itemizedlist>
<listitem><para><literal>-1</literal>, if this cursor is located before the cursor <replaceable>other</replaceable>,</para></listitem>
<listitem><para><literal>0</literal>, if both cursors equal and</para></listitem>
<listitem><para><literal>+1</literal>, if this cursor is located after the cursor <replaceable>other</replaceable>.</para></listitem>
</itemizedlist>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Cursor.equals(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this cursor and the cursor <replaceable>other</replaceable> are
equal, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String Cursor.toString();
</synopsis></term>
<listitem><para>
Returns the cursor as a string of the form <quote><literal>Cursor(line, column)</literal></quote>.
</para></listitem>
</varlistentry></variablelist>

</sect4>


<sect4 id="advanced-editing-tools-scripting-api-ranges">
<title>The Range Prototype</title>

<variablelist><varlistentry>
<term><synopsis>
Range();
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range()</literal> returns a Range at (0, 0) - (0, 0).
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Range(<parameter>Cursor <replaceable>start</replaceable></parameter>, <parameter>Cursor <replaceable>end</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range(<replaceable>start</replaceable>, <replaceable>end</replaceable>)</literal> returns the Range (<replaceable>start</replaceable>, <replaceable>end</replaceable>).
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Range(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>int <replaceable>startColumn</replaceable></parameter>, <parameter>int <replaceable>endLine</replaceable></parameter>, <parameter>int <replaceable>endColumn</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range(<replaceable>startLine</replaceable>, <replaceable>startColumn</replaceable>, <replaceable>endLine</replaceable>, <replaceable>endColumn</replaceable>)</literal>
returns the Range from (<replaceable>startLine</replaceable>, <replaceable>startColumn</replaceable>) to (<replaceable>endLine</replaceable>, <replaceable>endColumn</replaceable>).
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Range(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Copy constructor. Returns a copy of Range <replaceable>other</replaceable>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Range Range.clone();
</synopsis></term>
<listitem><para>
Returns a clone of the range.
</para>
<para>Example: <function>var clone = range.clone();</function>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.isValid();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if both start and end cursor are valid, otherwise <literal>false</literal>.
</para>
<para>Example: <function>var valid = range.isValid();</function>
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.invalid();
</synopsis></term>
<listitem><para>
Returns the Range from (-1, -1) to (-1, -1).
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.contains(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range contains the cursor position, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.contains(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range contains the Range <replaceable>other</replaceable>,
otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.containsColumn(<parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>column</replaceable> is in the half open interval
<literal>[start.column, end.column)</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.containsLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>line</replaceable> is in the half open interval
<literal>[start.line, end.line)</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.overlaps(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range and the range <replaceable>other</replaceable> share
a common region, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.overlapsLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>line</replaceable> is in the interval
<literal>[start.line, end.line]</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.overlapsColumn(<parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>column</replaceable> is in the interval
<literal>[start.column, end.column]</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool Range.equals(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range and the Range <replaceable>other</replaceable> are
equal, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String Range.toString();
</synopsis></term>
<listitem><para>
Returns the range as a string of the form <quote><literal>Range(Cursor(line, column), Cursor(line, column))</literal></quote>.
</para></listitem>
</varlistentry></variablelist>

</sect4>
</sect3>

<sect3 id="advanced-editing-tools-scripting-api-global">
<title>Global Functions</title>
<para>This section lists all global functions.</para>

<sect4 id="advanced-editing-tools-scripting-api-debug">
<title>Debugging</title>

<variablelist><varlistentry>
<term><synopsis>
void debug(<parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Prints <replaceable>text</replaceable> to <literal>stdout</literal> in the
console launching the application.
</para></listitem>
</varlistentry></variablelist>

</sect4>
<sect4 id="advanced-editing-tools-scripting-api-i18n">
<title>Translation</title>

<para>In order to support full localization, there are several functions to translate
strings in scripts, namely <literal>i18n</literal>, <literal>i18nc</literal>,
<literal>i18np</literal> and <literal>i18ncp</literal>. These functions behave
exactly like <ulink url="http://techbase.kde.org/Development/Tutorials/Localization/i18n">
KDE's translation functions</ulink>.
</para>

<para>The translation functions translate the wrapped strings through KDE's
translation system to the language used in the application. Strings in scripts
being developed in the official &kate; sources are automatically extracted and
translatable. In other words, as a &kate; developer you do not have to bother with
message extraction and translation. However, for 3rd-party scripts developed
outside of KDE, you have to extract and translate the messages yourself. Along
with your scripts you have to also distribute a translation catalog, that
includes all translated strings. Further, your script header then must
explicitly state the catalog to load by specifying
<literal>i18n-catalog</literal>.
</para>

<variablelist><varlistentry>
<term><synopsis>
void i18n(<parameter>String <replaceable>text</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates <replaceable>text</replaceable> into the language used by the application.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, etc.</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
void i18nc(<parameter>String <replaceable>context</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates <replaceable>text</replaceable> into the language used by the
application. Additionally, the string <replaceable>context</replaceable> is
visible to translators so they can provide a better translation.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, etc.</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
void i18np(<parameter>String <replaceable>singular</replaceable></parameter>, <parameter>String <replaceable>plural</replaceable></parameter>, <parameter>int <replaceable>number</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates either <replaceable>singular</replaceable> or
<replaceable>plural</replaceable> into the language used by the application,
depending on the given <replaceable>number</replaceable>.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, etc.</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
void i18ncp(<parameter>String <replaceable>context</replaceable></parameter>, <parameter>String <replaceable>singular</replaceable></parameter>, <parameter>String <replaceable>plural</replaceable></parameter>, <parameter>int <replaceable>number</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates either <replaceable>singular</replaceable> or
<replaceable>plural</replaceable> into the language used by the application,
depending on the given <replaceable>number</replaceable>. Additionally, the
string <replaceable>context</replaceable> is visible to translators so they
can provide a better translation. The arguments <replaceable>arg1</replaceable>,
..., are optional and used to replace the placeholders <literal>%1</literal>,
<literal>%2</literal>, etc.</para></listitem>
</varlistentry></variablelist>

</sect4>
</sect3>

<sect3 id="advanced-editing-tools-scripting-api-view">
<title>The View API</title>
<para>Whenever a script is being executed, there is a global variable
<quote><literal>view</literal></quote> representing the current active editor
view. The following is a list of all available View functions.

<variablelist><varlistentry>
<term><synopsis>
<function>Cursor view.cursorPosition()</function>
</synopsis></term>
<listitem><para>Returns the current cursor position in the view.</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
<function>void view.setCursorPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>)</function>
<function>void view.setCursorPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>)</function>
</synopsis></term>
<listitem><para>Returns the current cursor position in the view.</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void view.setCursorPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
void view.setCursorPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the current cursor position to either (line, column) or to the given cursor.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Cursor view.virtualCursorPosition();
</synopsis></term>
<listitem><para>
Returns the virtual cursor position with each tab counting the corresponding amount of spaces depending on the current tab width.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void view.setVirtualCursorPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
void view.setVirtualCursorPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the current virtual cursor position to (line, column) or to the given cursor.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String view.selectedText();
</synopsis></term>
<listitem><para>
Returns the selected text. If no text is selected, the returned string is empty.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool view.hasSelection();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the view has selected text, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Range view.selection();
</synopsis></term>
<listitem><para>
Returns the selected text range. The returned range is invalid if there is no
selected text.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void view.setSelection(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the selected text to the given range.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void view.removeSelectedText();
</synopsis></term>
<listitem><para>
Remove the selected text. If the view does not have any selected text, this
does nothing.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void view.selectAll();
</synopsis></term>
<listitem><para>
Selects the entire text in the document.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void view.clearSelection();
</synopsis></term>
<listitem><para>
Clears the text selection without removing the text.
</para></listitem>
</varlistentry></variablelist>
</para>
</sect3>

<sect3 id="advanced-editing-tools-scripting-api-document">
<title>The Document API</title>
<para>
Whenever a script is being executed, there is a global variable
<quote><literal>document</literal></quote> representing the current active
document. The following is a list of all available Document functions.

<variablelist><varlistentry>
<term><synopsis>
String document.fileName();
</synopsis></term>
<listitem><para>
Returns the document's filename or an empty string for unsaved text buffers.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.url();
</synopsis></term>
<listitem><para>
Returns the document's full url or an empty string for unsaved text buffers.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.mimeType();
</synopsis></term>
<listitem><para>
Returns the document's mime type or the mime type <literal>application/octet-stream</literal>
if no appropriate mime type could be found.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.encoding();
</synopsis></term>
<listitem><para>
Returns the currently used encoding to save the file.
</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
String document.highlightingMode();
</synopsis></term>
<listitem><para>
Returns the global highlighting mode used for the whole document.
</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
String document.highlightingModeAt(<parameter>Cursor <replaceable>pos</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns the highlighting mode used at the given position in the document.
</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
Array document.embeddedHighlightingModes();
</synopsis></term>
<listitem><para>
Returns an array of highlighting modes embedded in this document.
</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
bool document.isModified();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the document has unsaved changes (modified), otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.text();
</synopsis></term>
<listitem><para>
Returns the entire content of the document in a single text string. Newlines
are marked with the newline character <quote><literal>\n</literal></quote>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.text(<parameter>int <replaceable>fromLine</replaceable></parameter>, <parameter>int <replaceable>fromColumn</replaceable></parameter>, <parameter>int <replaceable>toLine</replaceable></parameter>, <parameter>int <replaceable>toColumn</replaceable></parameter>);
String document.text(<parameter>Cursor <replaceable>from</replaceable></parameter>, <parameter>Cursor <replaceable>to</replaceable></parameter>);
String document.text(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the text in the given range. It is recommended to use the cursor
    and range based version for better readability of the source code.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.line(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the given text line as string. The string is empty if the requested
    line is out of range.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.wordAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.wordAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the word at the given cursor position.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.charAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.charAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the character at the given cursor position.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.firstChar(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the first character in the given <replaceable>line</replaceable>
    that is not a whitespace. The first character is at column 0. If the line
    is empty or only contains whitespace characters, the returned string is
    empty.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.lastChar(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the last character in the given <replaceable>line</replaceable>
    that is not a whitespace. If the line is empty or only contains whitespace
    characters, the returned string is empty.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isSpace(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isSpace(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the character at the given cursor position is a whitespace,
    otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.matchesAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
bool document.matchesAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>text</replaceable> matches at the
    corresponding cursor position, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.startsWith(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>bool <replaceable>skipWhiteSpaces</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the line starts with <replaceable>text</replaceable>, otherwise <literal>false</literal>.
    The argument <replaceable>skipWhiteSpaces</replaceable> controls whether leading whitespaces are ignored.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.endsWith(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>bool <replaceable>skipWhiteSpaces</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the line ends with <replaceable>text</replaceable>, otherwise <literal>false</literal>.
    The argument <replaceable>skipWhiteSpaces</replaceable> controls whether trailing whitespaces are ignored.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.setText(<parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Sets the entire document text.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.clear();
</synopsis></term>
<listitem><para>
    Removes the entire text in the document.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.truncate(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.truncate(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Truncate the given line at the given column or cursor position. Returns <literal>true</literal>
    on success, or <literal>false</literal> if the given line is not part of the document range.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.insertText(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
bool document.insertText(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Inserts the <replaceable>text</replaceable> at the given cursor position.
    Returns <literal>true</literal> on success, or <literal>false</literal>, if the document is in read-only mode.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.removeText(<parameter>int <replaceable>fromLine</replaceable></parameter>, <parameter>int <replaceable>fromColumn</replaceable></parameter>, <parameter>int <replaceable>toLine</replaceable></parameter>, <parameter>int <replaceable>toColumn</replaceable></parameter>);
bool document.removeText(<parameter>Cursor <replaceable>from</replaceable></parameter>, <parameter>Cursor <replaceable>to</replaceable></parameter>);
bool document.removeText(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Removes the text in the given range. Returns <literal>true</literal> on success, or <literal>false</literal>, if
    the document is in read-only mode.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.insertLine(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Inserts text in the given line. Returns <literal>true</literal> on success, or <literal>false</literal>, if the
    document is in read-only mode or the line is not in the document range.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.removeLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Removes the given text line. Returns <literal>true</literal> on success, or <literal>false</literal>, if the
    document is in read-only mode or the line is not in the document range.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void document.joinLines(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>int <replaceable>endLine</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Joins the lines from <replaceable>startLine</replaceable> to <replaceable>endLine</replaceable>.
    Two succeeding text lines are always separated with a single space.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.lines();
</synopsis></term>
<listitem><para>
    Returns the amount of lines in the document.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.length();
</synopsis></term>
<listitem><para>
    Returns the number of characters in the document.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.lineLength(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the <replaceable>line</replaceable>'s length.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void document.editBegin();
</synopsis></term>
<listitem><para>
    Starts an edit group for undo/redo grouping. Make sure to always call
    <function>editEnd()</function> as often as you call
    <function>editBegin()</function>. Calling <function>editBegin()</function>
    internally uses a reference counter, i.e., this call can be nested.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
void document.editEnd();
</synopsis></term>
<listitem><para>
    Ends an edit group. The last call of <function>editEnd()</function> (i.e.
    the one for the first call of <function>editBegin()</function>) finishes
    the edit step.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.firstColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the first non-whitespace column in the given <replaceable>line</replaceable>.
    If there are only whitespaces in the line, the return value is <literal>-1</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.lastColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the last non-whitespace column in the given <replaceable>line</replaceable>.
    If there are only whitespaces in the line, the return value is <literal>-1</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.prevNonSpaceColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.prevNonSpaceColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the column with a non-whitespace characters starting at the given
    cursor position and searching backwards.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.nextNonSpaceColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.nextNonSpaceColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the column with a non-whitespace characters starting at the given
    cursor position and searching forwards.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.prevNonEmptyLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the next non-empty line containing non-whitespace characters
    searching backwards.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.nextNonEmptyLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the next non-empty line containing non-whitespace characters
    searching forwards.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isInWord(<parameter>String <replaceable>character</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>character</replaceable> with the
    given <replaceable>attribute</replaceable> can be part of a word, otherwise
    <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.canBreakAt(<parameter>String <replaceable>character</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>character</replaceable> with the given
    <replaceable>attribute</replaceable> is suited to wrap a line, otherwise
    <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.canComment(<parameter>int <replaceable>startAttribute</replaceable></parameter>, <parameter>int <replaceable>endAttribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if a range starting and ending with the given attributes is
    suited to be commented out, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.commentMarker(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for single line comments for a given <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.commentStart(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for the start of multi-line comments for a given
    <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.commentEnd(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for the end of multi-line comments for a given
    <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry></variablelist>



<variablelist><varlistentry>
<term><synopsis>
int document.attribute(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.attribute(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the attribute at the given cursor position.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isAttribute(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
bool document.isAttribute(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute at the given cursor position equals <replaceable>attribute</replaceable>,
    otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.attributeName(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.attributeName(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the attribute name as human readable text. This equals to the
    <literal>itemData</literal> name in the syntax highlighting files.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isAttributeName(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>name</replaceable></parameter>);
bool document.isAttributeName(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>name</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute name at a certain cursor position matches
    the given <replaceable>name</replaceable>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
String document.variable(<parameter>String <replaceable>key</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the value of the requested document variable <replaceable>key</replaceable>.
    If the document variable does not exist, the return value is an empty string.
</para></listitem>
</varlistentry></variablelist>



<variablelist><varlistentry>
<term><synopsis>
int document.firstVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the virtual column of the first non-whitespace character in the given
    line or <literal>-1</literal>, if the line is empty or contains only whitespace characters.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.lastVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the virtual column of the last non-whitespace character in the given
    line or <literal>-1</literal>, if the line is empty or contains only whitespace characters.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.toVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.toVirtualColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
Cursor document.toVirtualCursor(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Converts the given <quote>real</quote> cursor position to a virtual cursor position,
    either returning an int or a Cursor object.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.fromVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>virtualColumn</replaceable></parameter>);
int document.fromVirtualColumn(<parameter>Cursor <replaceable>virtualCursor</replaceable></parameter>);
Cursor document.fromVirtualCursor(<parameter>Cursor <replaceable>virtualCursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Converts the given virtual cursor position to a <quote>real</quote> cursor position,
    either returning an int or a Cursor object.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Cursor document.anchor(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>Char <replaceable>character</replaceable></parameter>);
Cursor document.anchor(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>Char <replaceable>character</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Searches backward for the given character starting from the given cursor.
    As example, if '(' is passed as character, this function will return the
    position of the opening '('. This reference counting, i.e. other '(...)'
    are ignored.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
Cursor document.rfind(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable> = -1</parameter>);
Cursor document.rfind(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable> = -1</parameter>);
</synopsis></term>
<listitem><para>
    Find backward the given text with the appropriate <replaceable>attribute</replaceable>.
    The argument <replaceable>attribute</replaceable> is ignored if it is set to
    <literal>-1</literal>. The returned cursor is invalid, if the text could not be found.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
int document.defStyleNum(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.defStyleNum(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the default style used at the given cursor position.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isCode(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isCode(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute at the given cursor position is not equal
    to all of the following styles: <literal>dsComment</literal>,
    <literal>dsString</literal>, <literal>dsRegionMarker</literal>,
    <literal>dsChar</literal>, <literal>dsOthers</literal>.
</para></listitem>
</varlistentry></variablelist>



<variablelist><varlistentry>
<term><synopsis>
bool document.isComment(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isComment(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsComment</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isString(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isString(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsString</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isRegionMarker(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isRegionMarker(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsRegionMarker</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isChar(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isChar(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsChar</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>


<variablelist><varlistentry>
<term><synopsis>
bool document.isOthers(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isOthers(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsOthers</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>
</para>

</sect3>
</sect2>
</sect1>
</chapter>
