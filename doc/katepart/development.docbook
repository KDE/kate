<!-- auto-generate scripting documentation (kwrite-devel@kde.org Re: [kate] doc/kate: document most of the new scripts in 4.10) -->
<chapter id="dev">
<chapterinfo>
<authorgroup>
<author>&TC.Hollingsworth; &TC.Hollingsworth.mail;</author>
<!-- TRANS:ROLES_OF_TRANSLATORS -->
</authorgroup>
</chapterinfo>
<title>Extending &katepart;</title>

<sect1 id="dev-intro">
<title>Introduction</title>

<para>Like any advanced text editor component, &katepart; offers a variety of
ways to extend its functionality.  You can <link linkend="dev-scripting">write
simple scripts to add functionality with &javascript;</link>.
Finally, once you have extended &katepart;, you are
welcome to <ulink url="https://kate-editor.org/join-us/">join us</ulink>
and share your enhancements with the world!</para>

</sect1>

<sect1 id="highlight">
<title>Working with Syntax Highlighting</title>

<sect2 id="highlight-overview">

<title>Overview</title>

<para>Syntax Highlighting is what makes the editor automatically
display text in different styles/colors, depending on the function of
the string in relation to the purpose of the file.  In program source
code for example, control statements may be rendered bold, while data
types and comments get different colors from the rest of the
text. This greatly enhances the readability of the text, and thus
helps the author to be more efficient and productive.</para>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="highlighted.png"/></imageobject>
<textobject><phrase>A C++ function, rendered with syntax
highlighting.</phrase></textobject>
<caption><para>A C++ function, rendered with syntax highlighting.</para>
</caption>
</mediaobject>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="unhighlighted.png"/></imageobject>
<textobject><phrase>The same C++ function, without
highlighting.</phrase></textobject>
<caption><para>The same C++ function, without highlighting.</para></caption>
</mediaobject>

<para>Of the two examples, which is easiest to read?</para>

<para>&kappname; comes with a flexible, configurable and capable system
for doing syntax highlighting, and the standard distribution provides
definitions for a wide range of programming, scripting and markup
languages and other text file formats. In addition you can
provide your own definitions in simple &XML; files.</para>

<para>&kappname; will automatically detect the right syntax rules when you
open a file, based on the &MIME; Type of the file, determined by its
extension, or, if it has none, the contents. Should you experience a
bad choice, you can manually set the syntax to use from the
<menuchoice><guimenu>Tools</guimenu><guisubmenu>Highlighting
</guisubmenu></menuchoice> menu.</para>

<para>The styles and colors used by each syntax highlight definition
can be configured using the <link
linkend="prefcolors-highlighting-text-styles">Highlighting Text Styles</link> tab of the
<link linkend="config-dialog">Config Dialog</link>, while the &MIME; Types and
file extensions it should be used for are handled by the <link
linkend="pref-open-save-modes-filetypes">Modes &amp; Filetypes</link>
tab.</para>

<note>
<para>Syntax highlighting is there to enhance the readability of
correct text, but you cannot trust it to validate your text. Marking
text for syntax is difficult depending on the format you are using,
and in some cases the authors of the syntax rules will be proud if 98%
of text gets correctly rendered, though most often you need a rare
style to see the incorrect 2%.</para>
</note>

</sect2>

<sect2 id="katehighlight-system">

<title>The &kappname; Syntax Highlight System</title>

<para>This section will discuss the &kappname; syntax highlighting
mechanism in more detail. It is for you if you want to know about
it, or if you want to change or create syntax definitions.</para>

<sect3 id="katehighlight-howitworks">

<title>How it Works</title>

<para>Whenever you open a file, one of the first things the &kappname;
editor does is detect which syntax definition to use for the
file. While reading the text of the file, and while you type away in
it, the syntax highlighting system will analyze the text using the
rules defined by the syntax definition and mark in it where different
contexts and styles begin and end.</para>

<para>When you type in the document, the new text is analyzed and marked on the
fly, so that if you delete a character that is marked as the beginning or end
of a context, the style of surrounding text changes accordingly.</para>

<para>The syntax definitions used by the &kappname; Syntax Highlighting System are
&XML; files, containing
<itemizedlist>
<listitem><para>Rules for detecting the role of text, organized into context blocks</para></listitem>
<listitem><para>Keyword lists</para></listitem>
<listitem><para>Style Item definitions</para></listitem>
</itemizedlist>
</para>

<para>When analyzing the text, the detection rules are evaluated in
the order in which they are defined, and if the beginning of the
current string matches a rule, the related context is used. The start
point in the text is moved to the final point at which that rule
matched and a new loop of the rules begins, starting in the context
set by the matched rule.</para>

</sect3>

<sect3 id="highlight-system-rules">
<title>Rules</title>

<para>The detection rules are the heart of the highlighting detection
system. A rule is a string, character or <link
linkend="regular-expressions">regular expression</link> against which
to match the text being analyzed. It contains information about which
style to use for the matching part of the text. It may switch the
working context of the system either to an explicitly mentioned
context or to the previous context used by the text.</para>

<para>Rules are organized in context groups. A context group is used
for main text concepts within the format, for example quoted text
strings or comment blocks in program source code. This ensures that
the highlighting system does not need to loop through all rules when
it is not necessary, and that some character sequences in the text can
be treated differently depending on the current context.
</para>

<para>Contexts may be generated dynamically to allow the usage of instance
specific data in rules.</para>

</sect3>

<sect3 id="highlight-context-styles-keywords">
<title>Context Styles and Keywords</title>

<para>In some programming languages, integer numbers are treated
differently from floating point ones by the compiler (the program that
converts the source code to a binary executable), and there may be
characters having a special meaning within a quoted string. In such
cases, it makes sense to render them differently from the surroundings
so that they are easy to identify while reading the text. So even if
they do not represent special contexts, they may be seen as such by
the syntax highlighting system, so that they can be marked for
different rendering.</para>

<para>A syntax definition may contain as many styles as required to
cover the concepts of the format it is used for.</para>

<para>In many formats, there are lists of words that represent a
specific concept. For example, in programming languages, control
statements are one concept, data type names another, and built in
functions of the language a third. The &kappname; Syntax Highlighting
System can use such lists to detect and mark words in the text to
emphasize concepts of the text formats.</para>

</sect3>

<sect3 id="kate-highlight-system-default-styles">
<title>Default Styles</title>

<para>If you open a C++ source file, a &Java; source file and an
&HTML; document in &kappname;, you will see that even
though the formats are different, and thus different words are chosen
for special treatment, the colors used are the same. This is because
&kappname; has a predefined list of Default Styles which are employed by
the individual syntax definitions.</para>

<para>This makes it easy to recognize similar concepts in different
text formats. For example, comments are present in almost any
programming, scripting or markup language, and when they are rendered
using the same style in all languages, you do not have to stop and
think to identify them within the text.</para>

<tip>
<para>All styles in a syntax definition use one of the default
styles. A few syntax definitions use more styles than there are
defaults, so if you use a format often, it may be worth launching the
configuration dialog to see if some concepts use the same
style. For example, there is only one default style for strings, but as
the Perl programming language operates with two types of strings, you
can enhance the highlighting by configuring those to be slightly
different. All <link linkend="kate-highlight-default-styles">available default styles</link>
will be explained later.</para>
</tip>

</sect3>

</sect2>

<sect2 id="katehighlight-xml-format">
<title>The Highlight Definition &XML; Format</title>

<sect3>
<title>Overview</title>

<para>&kappname; uses the Syntax-Highlighting framework from &kde-frameworks;.
The default highlighting &XML; files shipped with &kappname; are compiled
into the Syntax-Highlighting library by default.
</para>

<para>This section is an overview of the Highlight Definition &XML;
format. Based on a small example it will describe the main components
and their meaning and usage. The next section will go into detail with
the highlight detection rules.</para>

<para>The formal definition, also known as the <acronym>XSD</acronym> you
find in <ulink url="https://commits.kde.org/syntax-highlighting?path=data/schema">Syntax
Highlighting repository</ulink> in the file <filename>language.xsd</filename>
</para>

<para>Custom <filename class="extension">.xml</filename> highlight definition files are
located in <filename class="directory">org.kde.syntax-highlighting/syntax/</filename> in
your user folder found with <userinput><command>qtpaths</command><option> --paths
GenericDataLocation</option></userinput> which usually are
<filename class="directory"><envar>$HOME</envar>/.local/share/</filename>
and <filename class="directory">/usr/share/</filename>.
</para>

<para>In Flatpak and Snap packages, the above directory will not work
as the data location is different for each application.
In a Flatpak application, the location of custom &XML; files is usually
<filename class="directory"><envar>$HOME</envar>/.var/app/<replaceable>flatpak-package-name</replaceable>/data/org.kde.syntax-highlighting/syntax/</filename>
and in a Snap application that location is
<filename class="directory"><envar>$HOME</envar>/snap/<replaceable>snap-package-name</replaceable>/current/.local/share/org.kde.syntax-highlighting/syntax/</filename>.
</para>

<para>On &Windows; these files are located <filename>%USERPROFILE%&#92;AppData&#92;Local&#92;org.kde.syntax-highlighting&#92;syntax</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to <filename>C:&#92;Users&#92;<replaceable>user</replaceable></filename>.</para>

<para>In summary, for most configurations the directory of custom &XML;
files is as follows:</para>

<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>For local user</entry>
<entry><filename class="directory"><envar>$HOME</envar>/.local/share/org.kde.syntax-highlighting/syntax/</filename></entry>
</row>
<row>
<entry>For all users</entry>
<entry><filename class="directory">/usr/share/org.kde.syntax-highlighting/syntax/</filename></entry>
</row>
<row>
<entry>For Flatpak packages</entry>
<entry><filename class="directory"><envar>$HOME</envar>/.var/app/<replaceable>flatpak-package-name</replaceable>/data/org.kde.syntax-highlighting/syntax/</filename></entry>
</row>
<row>
<entry>For Snap packages</entry>
<entry><filename class="directory"><envar>$HOME</envar>/snap/<replaceable>snap-package-name</replaceable>/current/.local/share/org.kde.syntax-highlighting/syntax/</filename></entry>
</row>
<row>
<entry>On &Windows;</entry>
<entry><filename class="directory">%USERPROFILE%&#92;AppData&#92;Local&#92;org.kde.syntax-highlighting&#92;syntax</filename></entry>
</row>
<row>
<entry>On &macOS;</entry>
<entry><filename class="directory"><envar>$HOME</envar>/Library/Application Support/org.kde.syntax-highlighting/syntax/</filename></entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>If multiple files exist for the same language, the file with the highest <userinput>version</userinput> attribute in the <userinput>language</userinput> element will be loaded.</para>

<variablelist>
<title>Main sections of &kappname; Highlight Definition files</title>

<varlistentry>
<term>A highlighting file contains a header that sets the &XML; version:</term>
<listitem>
<programlisting>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</programlisting>
</listitem>
</varlistentry>

<varlistentry>
<term>The root of the definition file is the element <userinput>language</userinput>.
Available attributes are:</term>

<listitem>
<para>Required attributes:</para>
<para><userinput>name</userinput> sets the name of the language. It appears in the menus and dialogs afterwards.</para>
<para><userinput>section</userinput> specifies the category.</para>
<para><userinput>extensions</userinput> defines file extensions, such as &quot;*.cpp;*.h&quot;</para>
<para><userinput>version</userinput> specifies the current revision of the definition file in terms of an integer number. Whenever you change a highlighting definition file, make sure to increase this number.</para>
<para><userinput>kateversion</userinput> specifies the latest supported &kappname; version.</para>

<para>Optional attributes:</para>
<para><userinput>mimetype</userinput> associates files &MIME; type.</para>
<para><userinput>casesensitive</userinput> defines, whether the keywords are case sensitive or not.</para>
<para><userinput>priority</userinput> is necessary if another highlight definition file uses the same extensions. The higher priority will win.</para>
<para><userinput>author</userinput> contains the name of the author and his email-address.</para>
<para><userinput>license</userinput> contains the license, usually the MIT license for new syntax-highlighting files.</para>
<para><userinput>style</userinput> contains the provided language and is used by the indenters for the attribute <literal>required-syntax-style</literal>.</para>
<para><userinput>indenter</userinput> defines which indenter will be used by default. Available indenters are: <emphasis>ada, normal, cstyle, cmake, haskell, latex, lilypond, lisp, lua, pascal, python, replicode, ruby</emphasis> and <emphasis>xml</emphasis>.</para>
<para><userinput>hidden</userinput> defines whether the name should appear in &kappname;'s menus.</para>
<para>So the next line may look like this:</para>
<programlisting>
&lt;language name=&quot;C++&quot; version=&quot;1&quot; kateversion=&quot;2.4&quot; section=&quot;Sources&quot; extensions=&quot;*.cpp;*.h&quot; /&gt;
</programlisting>
</listitem>
</varlistentry>


<varlistentry>
<term>Next comes the <userinput>highlighting</userinput> element, which
contains the optional element <userinput>list</userinput> and the required
elements <userinput>contexts</userinput> and <userinput>itemDatas</userinput>.</term>
<listitem>
<para><userinput>list</userinput> elements contain a list of keywords. In
this case the keywords are <emphasis>class</emphasis> and <emphasis>const</emphasis>.
You can add as many lists as you need.</para>
<para>Since &kde-frameworks; 5.53, a list can include keywords from another
list or language/file, using the <userinput>include</userinput> element.
<userinput>##</userinput> is used to separate the list name and the language
definition name, in the same way as in the <userinput>IncludeRules</userinput> rule.
This is useful to avoid duplicating keyword lists, if you need to include the keywords
of another language/file. For example, the <emphasis>othername</emphasis> list
contains the <emphasis>str</emphasis> keyword and all the keywords of the
<emphasis>types</emphasis> list, which belongs to the <emphasis>ISO C++</emphasis>
language.</para>
<para>The <userinput>contexts</userinput> element contains all contexts.
The first context is by default the start of the highlighting. There are
two rules in the context <emphasis>Normal Text</emphasis>, which match
the list of keywords with the name <emphasis>somename</emphasis> and a
rule that detects a quote and switches the context to <emphasis>string</emphasis>.
To learn more about rules read the next chapter.</para>
<para>The third part is the <userinput>itemDatas</userinput> element. It
contains all color and font styles needed by the contexts and rules.
In this example, the <userinput>itemData</userinput> <emphasis>Normal Text</emphasis>,
<emphasis>String</emphasis> and <emphasis>Keyword</emphasis> are used.
</para>
<programlisting>
  &lt;highlighting&gt;
    &lt;list name=&quot;somename&quot;&gt;
      &lt;item&gt;class&lt;/item&gt;
      &lt;item&gt;const&lt;/item&gt;
    &lt;/list&gt;
    &lt;list name=&quot;othername&quot;&gt;
      &lt;item&gt;str&lt;/item&gt;
      &lt;include&gt;types##ISO C++&lt;/include&gt;
    &lt;/list&gt;
    &lt;contexts&gt;
      &lt;context attribute=&quot;Normal Text&quot; lineEndContext=&quot;#pop&quot; name=&quot;Normal Text&quot; &gt;
        &lt;keyword attribute=&quot;Keyword&quot; context=&quot;#stay&quot; String=&quot;somename&quot; /&gt;
        &lt;keyword attribute=&quot;Keyword&quot; context=&quot;#stay&quot; String=&quot;othername&quot; /&gt;
        &lt;DetectChar attribute=&quot;String&quot; context=&quot;string&quot; char=&quot;&amp;quot;&quot; /&gt;
      &lt;/context&gt;
      &lt;context attribute=&quot;String&quot; lineEndContext=&quot;#stay&quot; name=&quot;string&quot; &gt;
        &lt;DetectChar attribute=&quot;String&quot; context=&quot;#pop&quot; char=&quot;&amp;quot;&quot; /&gt;
      &lt;/context&gt;
    &lt;/contexts&gt;
    &lt;itemDatas&gt;
      &lt;itemData name=&quot;Normal Text&quot; defStyleNum=&quot;dsNormal&quot; /&gt;
      &lt;itemData name=&quot;Keyword&quot; defStyleNum=&quot;dsKeyword&quot; /&gt;
      &lt;itemData name=&quot;String&quot; defStyleNum=&quot;dsString&quot; /&gt;
    &lt;/itemDatas&gt;
  &lt;/highlighting&gt;
</programlisting>
</listitem>
</varlistentry>

<varlistentry>
<term>The last part of a highlight definition is the optional
<userinput>general</userinput> section. It may contain information
about keywords, code folding, comments, indentation, empty lines and
spell checking.</term>

<listitem>
<para>The <userinput>comment</userinput> section defines with what
string a single line comment is introduced. You also can define a
multiline comment using <emphasis>multiLine</emphasis> with the
additional attribute <emphasis>end</emphasis>. This is used if the
user presses the corresponding shortcut for <emphasis>comment/uncomment</emphasis>.</para>
<para>The <userinput>keywords</userinput> section defines whether
keyword lists are case sensitive or not. Other attributes will be
explained later.</para>
<para>The other sections, <userinput>folding</userinput>,
<userinput>emptyLines</userinput> and <userinput>spellchecking</userinput>,
are usually not necessary and are explained later.</para>
<programlisting>
  &lt;general&gt;
    &lt;comments&gt;
      &lt;comment name="singleLine" start="#"/&gt;
      &lt;comment name="multiLine" start="###" end="###" region="CommentFolding"/&gt;
    &lt;/comments&gt;
    &lt;keywords casesensitive="1"/&gt;
    &lt;folding indentationsensitive="0"/&gt;
    &lt;emptyLines&gt;
      &lt;emptyLine regexpr="\s+"/&gt;
      &lt;emptyLine regexpr="\s*#.*"/&gt;
    &lt;/emptyLines&gt;
    &lt;spellchecking&gt;
      &lt;encoding char="&#225;" string="\&#39;a"/&gt;
      &lt;encoding char="&#224;" string="\&#96;a"/&gt;
    &lt;/spellchecking&gt;
  &lt;/general&gt;
&lt;/language&gt;
</programlisting>
</listitem>
</varlistentry>

</variablelist>


</sect3>

<sect3 id="kate-highlight-sections">
<title>The Sections in Detail</title>
<para>This part will describe all available attributes for contexts,
itemDatas, keywords, comments, code folding and indentation.</para>

<variablelist>
<varlistentry>
<term>The element <userinput>context</userinput> belongs in the group
<userinput>contexts</userinput>. A context itself defines context specific
rules such as what should happen if the highlight system reaches the end of a
line. Available attributes are:</term>


<listitem>
<para><userinput>name</userinput> states the context name. Rules will use this name
to specify the context to switch to if the rule matches.</para>

<para><userinput>attribute</userinput> identifies the style to use for a
character when no rule matches or when a rule does not specify attribute.
In the latter case, <emphasis>attribute</emphasis> of the context specified
in the rule's <emphasis>context</emphasis> will be used.</para>

<para><userinput>lineEndContext</userinput> defines the context the highlight
system switches to if it reaches the end of a line. This may either be a name
of another context, <userinput>#stay</userinput> to not switch the context
(&eg;. do nothing) or <userinput>#pop</userinput> which will cause it to leave this
context. It is possible to use for example <userinput>#pop#pop#pop</userinput>
to pop three times, or even <userinput>#pop#pop!OtherContext</userinput> to pop
two times and switch to the context named <userinput>OtherContext</userinput>.
It is also possible to switch to a context that belongs to another language definition,
in the same way as in the <userinput>IncludeRules</userinput> rules, &eg;,
<userinput>SomeContext##JavaScript</userinput>.
Context switches are also described in <xref linkend="kate-highlight-rules-detailled"/>.
Default: #stay.</para>
<para><userinput>lineEmptyContext</userinput> defines the context if an empty
line is encountered. The nomenclature of context switches is the same as
previously described in <emphasis>lineEndContext</emphasis>. Default: #stay.</para>
<para><userinput>fallthroughContext</userinput> specifies the next context to
switch to if no rule matches. The nomenclature of context switches is
the same as previously described in <emphasis>lineEndContext</emphasis>.
Default: #stay.</para>
<para><userinput>fallthrough</userinput> defines if the highlight system switches
to the context specified in <userinput>fallthroughContext</userinput> if no rule
matches. Note that since &kde; &frameworks; 5.62 this attribute is deprecated
in favor of <userinput>fallthroughContext</userinput>, since if the
<userinput>fallthroughContext</userinput> attribute is present it is implicitly
understood that the value of <userinput>fallthrough</userinput> is
<emphasis>true</emphasis>. Default: <emphasis>false</emphasis>.</para>
<para><userinput>noIndentationBasedFolding</userinput> disables indentation-based folding
in the context. If indentation-based folding is not activated, this attribute is useless.
This is defined in the element <emphasis>folding</emphasis> of the group <emphasis>general</emphasis>.
Default: <emphasis>false</emphasis>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>itemData</userinput> is in the group
<userinput>itemDatas</userinput>. It defines the font style and colors.
So it is possible to define your own styles and colors. However, we
recommend you stick to the default styles if possible so that the user
will always see the same colors used in different languages. Though,
sometimes there is no other way and it is necessary to change color
and font attributes. The attributes name and defStyleNum are required,
the others are optional. Available attributes are:</term>

<listitem>
<para><userinput>name</userinput> sets the name of the itemData.
Contexts and rules will use this name in their attribute
<emphasis>attribute</emphasis> to reference an itemData.</para>
<para><userinput>defStyleNum</userinput> defines which default style to use.
Available default styles are explained in detail later.</para>
<para><userinput>color</userinput> defines a color. Valid formats are
'#rrggbb' or '#rgb'.</para>
<para><userinput>selColor</userinput> defines the selection color.</para>
<para><userinput>italic</userinput> if <emphasis>true</emphasis>, the text will be italic.</para>
<para><userinput>bold</userinput> if <emphasis>true</emphasis>, the text will be bold.</para>
<para><userinput>underline</userinput> if <emphasis>true</emphasis>, the text will be underlined.</para>
<para><userinput>strikeOut</userinput> if <emphasis>true</emphasis>, the text will be struck out.</para>
<para><userinput>spellChecking</userinput> if <emphasis>true</emphasis>, the text will be spellchecked.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>keywords</userinput> in the group
<userinput>general</userinput> defines keyword properties. Available attributes are:</term>

<listitem>
<para><userinput>casesensitive</userinput> may be <emphasis>true</emphasis>
or <emphasis>false</emphasis>. If <emphasis>true</emphasis>, all keywords
are matched case sensitively.</para>
<para><userinput>weakDeliminator</userinput> is a list of characters that
do not act as word delimiters. For example, the dot <userinput>'.'</userinput>
is a word delimiter. Assume a keyword in a <userinput>list</userinput> contains
a dot, it will only match if you specify the dot as a weak delimiter.</para>
<para><userinput>additionalDeliminator</userinput> defines additional delimiters.</para>
<para><userinput>wordWrapDeliminator</userinput> defines characters after which a
line wrap may occur.</para>
<para>Default delimiters and word wrap delimiters are the characters
<userinput>.():!+,-&lt;=&gt;%&amp;*/;?[]^{|}~\</userinput>, space (<userinput>' '</userinput>)
and tabulator (<userinput>'\t'</userinput>).</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>comment</userinput> in the group
<userinput>comments</userinput> defines comment properties which are used
for <menuchoice><guimenu>Tools</guimenu><guimenuitem>Comment</guimenuitem></menuchoice>,
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Uncomment</guimenuitem></menuchoice> and
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Toggle Comment</guimenuitem></menuchoice>.
Available attributes are:</term>

<listitem>
<para><userinput>name</userinput> is either <emphasis>singleLine</emphasis>
or <emphasis>multiLine</emphasis>. If you choose <emphasis>multiLine</emphasis>
the attributes <emphasis>end</emphasis> and <emphasis>region</emphasis> are
required. If you choose <emphasis>singleLine</emphasis> you can add the optional
attribute <emphasis>position</emphasis>.</para>
<para><userinput>start</userinput> defines the string used to start a comment.
In C++ this would be &quot;/*&quot; in multiline comments. This attribute is required
for types <emphasis>multiLine</emphasis> and <emphasis>singleLine</emphasis>.</para>
<para><userinput>end</userinput> defines the string used to close a comment.
In C++ this would be &quot;*/&quot;. This attribute is only available and is
required for comments of type <emphasis>multiLine</emphasis>.</para>
<para><userinput>region</userinput> should be the name of the foldable
multiline comment. Assume you have <emphasis>beginRegion="Comment"</emphasis>
... <emphasis>endRegion="Comment"</emphasis> in your rules, you should use
<emphasis>region="Comment"</emphasis>. This way uncomment works even if you
do not select all the text of the multiline comment. The cursor only must be
in the multiline comment. This attribute is only available for type
<emphasis>multiLine</emphasis>.</para>
<para><userinput>position</userinput> defines where the single line comment is inserted.
By default, the single line comment is placed at the beginning of the line at column 0,
but if you use <emphasis>position="afterwhitespace"</emphasis> the comment is
inserted after leading whitespaces right, before the first non-whitespace character.
This is useful for putting comments correctly in languages where indentation
is important, such as Python or YAML. This attribute is optional and the only
possible value is <emphasis>afterwhitespace</emphasis>.
This is only available for type <emphasis>singleLine</emphasis>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>folding</userinput> in the group
<userinput>general</userinput> defines code folding properties.
Available attributes are:</term>

<listitem>
<para><userinput>indentationsensitive</userinput> if <emphasis>true</emphasis>, the code folding markers
will be added indentation based, as in the scripting language Python. Usually you
do not need to set it, as it defaults to <emphasis>false</emphasis>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>emptyLine</userinput> in the group <userinput>emptyLines</userinput>
defines which lines should be treated as empty lines. This allows modifying the behavior of the
<emphasis>lineEmptyContext</emphasis> attribute in the elements <userinput>context</userinput>.
Available attributes are:</term>

<listitem>
<para><userinput>regexpr</userinput> defines a regular expression that will be treated as an empty line.
By default, empty lines do not contain any characters, therefore, this adds additional empty lines,
for example, if you want lines with spaces to also be considered empty lines.
However, in most syntax definitions you do not need to set this attribute.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>encoding</userinput> in the group <userinput>spellchecking</userinput>
defines a character encoding for spell checking. Available attributes:</term>

<listitem>
<para><userinput>char</userinput> is a encoded character.</para>
<para><userinput>string</userinput> is a sequence of characters that will be encoded as
the character <emphasis>char</emphasis> in the spell checking.
For example, in the language LaTeX, the string <userinput>\&quot;{A}</userinput> represents
the character <userinput>&#196;</userinput>.</para>
</listitem>
</varlistentry>


</variablelist>


</sect3>

<sect3 id="kate-highlight-default-styles">
<title>Available Default Styles</title>
<para>Default Styles were <link linkend="kate-highlight-system-default-styles">already explained</link>,
as a short summary: Default styles are predefined font and color styles.</para>
<variablelist>
<varlistentry>
<term>General default styles:</term>
<listitem>
<para><userinput>dsNormal</userinput>, when no special highlighting is required.</para>
<para><userinput>dsKeyword</userinput>, built-in language keywords.</para>
<para><userinput>dsFunction</userinput>, function calls and definitions.</para>
<para><userinput>dsVariable</userinput>, if applicable: variable names (&eg; $someVar in PHP/Perl).</para>
<para><userinput>dsControlFlow</userinput>, control flow keywords like if, else, switch, break, return, yield, ...</para>
<para><userinput>dsOperator</userinput>, operators like + - * / :: &lt; &gt;</para>
<para><userinput>dsBuiltIn</userinput>, built-in functions, classes, and objects.</para>
<para><userinput>dsExtension</userinput>, common extensions, such as &Qt; classes and functions/macros in C++ and Python.</para>
<para><userinput>dsPreprocessor</userinput>, preprocessor statements or macro definitions.</para>
<para><userinput>dsAttribute</userinput>, annotations such as @override and __declspec(...).</para>
</listitem>
</varlistentry>

<varlistentry>
<term>String-related default styles:</term>
<listitem>
<para><userinput>dsChar</userinput>, single characters, such as 'x'.</para>
<para><userinput>dsSpecialChar</userinput>, chars with special meaning in strings such as escapes, substitutions, or regex operators.</para>
<para><userinput>dsString</userinput>, strings like "hello world".</para>
<para><userinput>dsVerbatimString</userinput>, verbatim or raw strings like 'raw \backlash' in Perl, CoffeeScript, and shells, as well as r'\raw' in Python.</para>
<para><userinput>dsSpecialString</userinput>, SQL, regexes, HERE docs, &latex; math mode, ...</para>
<para><userinput>dsImport</userinput>, import, include, require of modules.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Number-related default styles:</term>
<listitem>
<para><userinput>dsDataType</userinput>, built-in data types like int, void, u64.</para>
<para><userinput>dsDecVal</userinput>, decimal values.</para>
<para><userinput>dsBaseN</userinput>, values with a base other than 10.</para>
<para><userinput>dsFloat</userinput>, floating point values.</para>
<para><userinput>dsConstant</userinput>, built-in and user defined constants like PI.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Comment and documentation-related default styles:</term>
<listitem>
<para><userinput>dsComment</userinput>, comments.</para>
<para><userinput>dsDocumentation</userinput>, /** Documentation comments */ or """docstrings""".</para>
<para><userinput>dsAnnotation</userinput>, documentation commands like @param, @brief.</para>
<para><userinput>dsCommentVar</userinput>, the variable names used in above commands, like "foobar" in @param foobar.</para>
<para><userinput>dsRegionMarker</userinput>, region markers like //BEGIN, //END in comments.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Other default styles:</term>
<listitem>
<para><userinput>dsInformation</userinput>, notes and tips like @note in doxygen.</para>
<para><userinput>dsWarning</userinput>, warnings like @warning in doxygen.</para>
<para><userinput>dsAlert</userinput>, special words like TODO, FIXME, XXXX.</para>
<para><userinput>dsError</userinput>, error highlighting and wrong syntax.</para>
<para><userinput>dsOthers</userinput>, when nothing else fits.</para>
</listitem>
</varlistentry>
</variablelist>

</sect3>

</sect2>

<sect2 id="kate-highlight-rules-detailled">
<title>Highlight Detection Rules</title>

<para>This section describes the syntax detection rules.</para>

<para>Each rule can match zero or more characters at the beginning of
the string they are tested against. If the rule matches, the matching
characters are assigned the style or <emphasis>attribute</emphasis>
defined by the rule, and a rule may ask that the current context is
switched.</para>

<para>A rule looks like this:</para>

<programlisting>&lt;RuleName attribute=&quot;(identifier)&quot; context=&quot;(identifier)&quot; [rule specific attributes] /&gt;</programlisting>

<para>The <emphasis>attribute</emphasis> identifies the style to use
for matched characters by name, and the <emphasis>context</emphasis>
identifies the context to use from here.</para>

<para>The <emphasis>context</emphasis> can be identified by:</para>

<itemizedlist>
<listitem>
<para>An <emphasis>identifier</emphasis>, which is the name of the other
context.</para>
</listitem>
<listitem>
<para>An <emphasis>order</emphasis> telling the engine to stay in the
current context (<userinput>#stay</userinput>), or to pop back to a
previous context used in the string (<userinput>#pop</userinput>).
An empty or absent context is equivalent to <userinput>#stay</userinput>.</para>
<para>To go back more steps, the #pop keyword can be repeated:
<userinput>#pop#pop#pop</userinput></para>
</listitem>
<listitem>
<para>An <emphasis>order</emphasis> followed by an exclamation mark
(<emphasis>!</emphasis>) and an <emphasis>identifier</emphasis>, which
will make the engine first follow the order and then switch to the
other context, &eg; <userinput>#pop#pop!OtherContext</userinput>.</para>
</listitem>
<listitem>
<para>An <emphasis>identifier</emphasis>, which is a context name,
followed by two hashes (<userinput>##</userinput>) and another
<emphasis>identifier</emphasis>, which is the name of a language definition.
This naming is similar to that used in <userinput>IncludeRules</userinput>
rules and allows you to switch to a context belonging to another syntax
highlighting definition, e.g. <userinput>SomeContext##JavaScript</userinput>.
</para>
</listitem>
</itemizedlist>

<para>Rule specific attributes varies and are described in the
following sections.</para>

<itemizedlist>
<title>Common attributes</title>
<para>All rules have the following attributes in common and are
available whenever <userinput>(common attributes)</userinput> appears.
All attributes are optional.
</para>

<listitem>
<para><emphasis>attribute</emphasis>: An attribute maps to a defined <emphasis>itemData</emphasis>. Default: <emphasis>attribute</emphasis> from the context specified in <emphasis>context</emphasis> attribute.</para>
</listitem>
<listitem>
<para><emphasis>context</emphasis>: Specify the context to which the highlighting system switches if the rule matches. Default: #stay.</para>
</listitem>
<listitem>
<para><emphasis>beginRegion</emphasis>: Start a code folding block. Default: unset.</para>
</listitem>
<listitem>
<para><emphasis>endRegion</emphasis>: Close a code folding block. Default: unset.</para>
</listitem>
<listitem>
<para><emphasis>lookAhead</emphasis>: If <emphasis>true</emphasis>, the
highlighting system will not process the matches length.
Default: <emphasis>false</emphasis>.</para>
</listitem>
<listitem>
<para><emphasis>firstNonSpace</emphasis>: Match only, if the string is
the first non-whitespace in the line. Default: <emphasis>false</emphasis>.</para>
</listitem>
<listitem>
<para><emphasis>column</emphasis>: Match only, if the column matches. Default: unset.</para>
</listitem>
</itemizedlist>

<itemizedlist>
<title>Dynamic rules</title>
<para>Some rules allow the optional attribute <userinput>dynamic</userinput>
of type boolean that defaults to <emphasis>false</emphasis>. If dynamic is
<emphasis>true</emphasis>, a rule can use placeholders representing the text
matched by a <emphasis>regular expression</emphasis> rule that switched to the
current context in its <userinput>string</userinput> or
<userinput>char</userinput> attributes. In a <userinput>string</userinput>,
the placeholder <replaceable>%N</replaceable> (where N is a number) will be
replaced with the corresponding capture <replaceable>N</replaceable>
from the calling regular expression, starting from 1. In a
<userinput>char</userinput> the placeholder must be a number
<replaceable>N</replaceable> and it will be replaced with the first character of
the corresponding capture <replaceable>N</replaceable> from the calling regular
expression. Whenever a rule allows this attribute it will contain a
<emphasis>(dynamic)</emphasis>.</para>

<listitem>
<para><emphasis>dynamic</emphasis>: may be <emphasis>(true|false)</emphasis>.</para>
</listitem>
</itemizedlist>

<para><userinput>How does it work:</userinput></para>

<para>In the <link linkend="regular-expressions">regular expressions</link> of the
<userinput>RegExpr</userinput> rules, all text within simple curved brackets
<userinput>(PATTERN)</userinput> is captured and remembered.
These captures can be used in the context to which it is switched, in the rules with the
attribute <userinput>dynamic</userinput> <emphasis>true</emphasis>, by
<replaceable>%N</replaceable> (in <emphasis>String</emphasis>) or
<replaceable>N</replaceable> (in <emphasis>char</emphasis>).</para>

<para>It is important to mention that a text captured in a <userinput>RegExpr</userinput> rule is
only stored for the switched context, specified in its <userinput>context</userinput> attribute.</para>

<tip>
<itemizedlist>

<listitem>
<para>If the captures will not be used, both by dynamic rules and in the same regular expression,
<userinput>non-capturing groups</userinput> should be used: <userinput>(?:PATTERN)</userinput></para>
<para>The <emphasis>lookahead</emphasis> or <emphasis>lookbehind</emphasis> groups such as
<userinput>(?=PATTERN)</userinput>, <userinput>(?!PATTERN)</userinput> or
<userinput>(?&lt;=PATTERN)</userinput> are not captured.
See <link linkend="regular-expressions">Regular Expressions</link> for more information.</para>
</listitem>

<listitem>
<para>The capture groups can be used within the same regular expression,
using <replaceable>\N</replaceable> instead of <replaceable>%N</replaceable> respectively.
For more information, see <link linkend="regex-capturing">Capturing matching text (back references)</link>
in <link linkend="regular-expressions">Regular Expressions</link>.</para>
</listitem>

</itemizedlist>
</tip>

<para>Example 1:</para>
<para>In this simple example, the text matched by the regular expression
<userinput>=*</userinput> is captured and inserted into <replaceable>%1</replaceable>
in the dynamic rule. This allows the comment to end with the same amount of
<userinput>=</userinput> as at the beginning. This matches text like:
<userinput>[[ comment ]]</userinput>, <userinput>[=[ comment ]=]</userinput> or
<userinput>[=====[ comment ]=====]</userinput>.</para>
<para>In addition, the captures are available only in the switched context
<emphasis>Multi-line Comment</emphasis>.</para>

<programlisting>
&lt;context name="Normal" attribute="Normal Text" lineEndContext="#stay"&gt;
  &lt;RegExpr context="Multi-line Comment" attribute="Comment" String="\[(=*)\[" beginRegion="RegionComment"/&gt;
&lt;/context&gt;
&lt;context name="Multi-line Comment" attribute="Comment" lineEndContext="#stay"&gt;
  &lt;StringDetect context="#pop" attribute="Comment" String="]%1]" dynamic="true" endRegion="RegionComment"/&gt;
&lt;/context&gt;
</programlisting>

<para>Example 2:</para>
<para>In the dynamic rule, <replaceable>%1</replaceable> corresponds to the capture that matches
<userinput>#+</userinput>, and <replaceable>%2</replaceable> to <userinput>&amp;quot;+</userinput>.
This matches text as: <userinput>#label""""inside the context""""#</userinput>.</para>
<para>These captures will not be available in other contexts, such as
<emphasis>OtherContext</emphasis>, <emphasis>FindEscapes</emphasis> or
<emphasis>SomeContext</emphasis>.</para>

<programlisting>
&lt;context name="SomeContext" attribute="Normal Text" lineEndContext="#stay"&gt;
  &lt;RegExpr context="#pop!NamedString" attribute="String" String="(#+)(?:[\w-]|[^[:ascii:]])(&amp;quot;+)"/&gt;
&lt;/context&gt;
&lt;context name="NamedString" attribute="String" lineEndContext="#stay"&gt;
  &lt;RegExpr context="#pop!OtherContext" attribute="String" String="%2(?:%1)?" dynamic="true"/&gt;
  &lt;DetectChar context="FindEscapes" attribute="Escape" char="\"/&gt;
&lt;/context&gt;
</programlisting>

<para>Example 3:</para>
<para>This matches text like:
<userinput>Class::function&lt;T&gt;( ... )</userinput>.</para>

<programlisting>
&lt;context name="Normal" attribute="Normal Text" lineEndContext="#stay"&gt;
  &lt;RegExpr context="FunctionName" lookAhead="true"
              String="\b([a-zA-Z_][\w-]*)(::)([a-zA-Z_][\w-]*)(?:&amp;lt;[\w\-\s]*&amp;gt;)?(\()"/&gt;
&lt;/context&gt;
&lt;context name="FunctionName" attribute="Normal Text" lineEndContext="#pop"&gt;
  &lt;StringDetect context="#stay" attribute="Class" String="%1" dynamic="true"/&gt;
  &lt;StringDetect context="#stay" attribute="Operator" String="%2" dynamic="true"/&gt;
  &lt;StringDetect context="#stay" attribute="Function" String="%3" dynamic="true"/&gt;
  &lt;DetectChar context="#pop" attribute="Normal Text" char="4" dynamic="true"/&gt;
&lt;/context&gt;
</programlisting>

<itemizedlist>
<title>Local deliminators</title>
<para>Some rules allow the optional attributes <userinput>weakDeliminator</userinput>
and <userinput>additionalDeliminator</userinput> which are combined with attributes
of the same name of <userinput>keywords</userinput> tag. For example, when
<userinput>'%'</userinput> is a weak delimiter of <userinput>keywords</userinput>,
it can become a word delimiter only for a rule by putting it in its
<userinput>additionalDeliminator</userinput> attribute. Whenever a rule allows these
attributes it will contain a <emphasis>(local deliminators)</emphasis>.</para>

<listitem>
<para><emphasis>weakDeliminator</emphasis>: list of characters that do not act as word
delimiters.</para>
</listitem>
<listitem>
<para><emphasis>additionalDeliminator</emphasis>: defines additional delimiters.</para>
</listitem>
</itemizedlist>

<sect3 id="highlighting-rules-in-detail">
<title>The Rules in Detail</title>

<variablelist>
<varlistentry>
<term>DetectChar</term>
<listitem>
<para>Detect a single specific character. Commonly used for example to
find the ends of quoted strings.</para>
<programlisting>&lt;DetectChar char=&quot;(character)&quot; (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>char</userinput> attribute defines the character
to match.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Detect2Chars</term>
<listitem>
<para>Detect two specific characters in a defined order.</para>
<programlisting>&lt;Detect2Chars char=&quot;(character)&quot; char1=&quot;(character)&quot; (common attributes) /&gt;</programlisting>
<para>The <userinput>char</userinput> attribute defines the first character to match,
<userinput>char1</userinput> the second.</para>
<para>This rule is present for historical reasons and for readability it's
preferable to use <userinput>StringDetect</userinput>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>AnyChar</term>
<listitem>
<para>Detect one character of a set of specified characters.</para>
<programlisting>&lt;AnyChar String=&quot;(string)&quot; (common attributes) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the set of
characters.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>StringDetect</term>
<listitem>
<para>Detect an exact string.</para>
<programlisting>&lt;StringDetect String=&quot;(string)&quot; [insensitive=&quot;true|false&quot;] (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the string
to match. The <userinput>insensitive</userinput> attribute defaults to
<emphasis>false</emphasis> and is passed to the string comparison
function. If the value is <emphasis>true</emphasis> insensitive
comparing is used.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>WordDetect</term>
<listitem>
<para>Detect an exact string but additionally require word boundaries
such as a dot <userinput>'.'</userinput> or a whitespace on the beginning
and the end of the word. Think of <userinput>\b&lt;string&gt;\b</userinput>
in terms of a regular expression, but it is faster than the rule <userinput>RegExpr</userinput>.</para>
<programlisting>&lt;WordDetect String=&quot;(string)&quot; [insensitive=&quot;true|false&quot;] (common attributes) (local deliminators) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the string
to match. The <userinput>insensitive</userinput> attribute defaults to
<emphasis>false</emphasis> and is passed to the string comparison
function. If the value is <emphasis>true</emphasis> insensitive
comparing is used.</para>
<para>Since: &kate; 3.5 (&kde; 4.5)</para>
</listitem>
</varlistentry>

<varlistentry>
<term>RegExpr</term>
<listitem>
<para>Matches against a regular expression.</para>
<programlisting>&lt;RegExpr String=&quot;(string)&quot; [insensitive=&quot;true|false&quot;] [minimal=&quot;true|false&quot;] (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the regular
expression.</para>
<para><userinput>insensitive</userinput> defaults to
<emphasis>false</emphasis> and is passed to the regular expression
engine.</para>
<para><userinput>minimal</userinput> defaults to
<emphasis>false</emphasis> and is passed to the regular expression
engine.</para>
<para>Because the rules are always matched against the beginning of
the current string, a regular expression starting with a caret
(<literal>^</literal>) indicates that the rule should only be
matched against the start of a line.</para>
<para>See <link linkend="regular-expressions">Regular Expressions</link>
for more information on those.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>keyword</term>
<listitem>
<para>Detect a keyword from a specified list.</para>
<programlisting>&lt;keyword String=&quot;(list name)&quot; (common attributes) (local deliminators) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute identifies the
keyword list by name. A list with that name must exist.</para>
<para>The highlighting system processes keyword rules in a very optimized way.
This makes it an absolute necessity that any keywords to be matched need to be
surrounded by defined delimiters, either implied (the default delimiters),
or explicitly specified within the <emphasis>additionalDeliminator</emphasis>
property of the <emphasis>keywords</emphasis> tag.</para>
<para>If a keyword to be matched shall contain a delimiter character, this
respective character must be added to the <emphasis>weakDeliminator</emphasis>
property of the <emphasis>keywords</emphasis> tag.  This character will then
loose its delimiter property in all <emphasis>keyword</emphasis> rules. It is
also possible to use the <emphasis>weakDeliminator</emphasis> attribute of
<emphasis>keyword</emphasis> so that this modification only applies to this
rule.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Int</term>
<listitem>
<para>Detect an integer number (as the regular expression: <userinput>\b[0-9]+</userinput>).</para>
<para><programlisting>&lt;Int (common attributes) (local deliminators) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Float</term>
<listitem>
<para>Detect a floating point number (as the regular expression:
<userinput>(\b[0-9]+\.[0-9]*|\.[0-9]+)([eE][-+]?[0-9]+)?</userinput>).</para>
<para><programlisting>&lt;Float (common attributes) (local deliminators) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>HlCOct</term>
<listitem>
<para>Detect an octal point number representation (as the regular
expression: <userinput>\b0[0-7]+</userinput>).</para>
<para><programlisting>&lt;HlCOct (common attributes) (local deliminators) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>HlCHex</term>
<listitem>
<para>Detect a hexadecimal number representation (as a regular expression:
<userinput>\b0[xX][0-9a-fA-F]+</userinput>).</para>
<para><programlisting>&lt;HlCHex (common attributes) (local deliminators) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>HlCStringChar</term>
<listitem>
<para>Detect an escaped character.</para>
<para><programlisting>&lt;HlCStringChar (common attributes) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>

<para>It matches literal representations of characters commonly used in
program code, for example <userinput>\n</userinput>
(newline) or <userinput>\t</userinput> (TAB).</para>

<para>The following characters will match if they follow a backslash
(<literal>\</literal>):
<userinput>abefnrtv&quot;'?\</userinput>. Additionally, escaped
hexadecimal numbers such as for example <userinput>\xff</userinput> and
escaped octal numbers, for example <userinput>\033</userinput> will
match.</para>

</listitem>
</varlistentry>

<varlistentry>
<term>HlCChar</term>
<listitem>
<para>Detect an C character.</para>
<para><programlisting>&lt;HlCChar (common attributes) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>

<para>It matches C characters enclosed in a tick (Example: <userinput>'c'</userinput>).
The ticks may be a simple character or an escaped character.
See HlCStringChar for matched escaped character sequences.</para>

</listitem>
</varlistentry>

<varlistentry>
<term>RangeDetect</term>
<listitem>
<para>Detect a string with defined start and end characters.</para>
<programlisting>&lt;RangeDetect char=&quot;(character)&quot;  char1=&quot;(character)&quot; (common attributes) /&gt;</programlisting>
<para><userinput>char</userinput> defines the character starting the range,
<userinput>char1</userinput> the character ending the range.</para>
<para>Useful to detect for example small quoted strings and the like, but
note that since the highlighting engine works on one line at a time, this
will not find strings spanning over a line break.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>LineContinue</term>
<listitem>
<para>Matches a specified char at the end of a line.</para>
<programlisting>&lt;LineContinue (common attributes) [char="\"] /&gt;</programlisting>
<para><userinput>char</userinput> optional character to match, default is
backslash (<userinput>'\'</userinput>). New since &kde; 4.13.</para>
<para>This rule is useful for switching context at end of line. This is needed for
 example in C/C++ to continue macros or strings.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>IncludeRules</term>
<listitem>
<para>Include rules from another context or language/file.</para>
<programlisting>&lt;IncludeRules context=&quot;contextlink&quot; [includeAttrib=&quot;true|false&quot;] /&gt;</programlisting>

<para>The <userinput>context</userinput> attribute defines which context to include.</para>
<para>If it is a simple string it includes all defined rules into the current context, example:
<programlisting>&lt;IncludeRules context=&quot;anotherContext&quot; /&gt;</programlisting></para>

<para>
If the string contains a <userinput>##</userinput> the highlight system
will look for a context from another language definition with the given name,
for example
<programlisting>&lt;IncludeRules context=&quot;String##C++&quot; /&gt;</programlisting>
would include the context <emphasis>String</emphasis> from the <emphasis>C++</emphasis>
highlighting definition.</para>
<para>If <userinput>includeAttrib</userinput> attribute is
<emphasis>true</emphasis>, change the destination attribute to the one of
the source. This is required to make, for example, commenting work, if text
matched by the included context is a different highlight from the host
context.
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>DetectSpaces</term>
<listitem>
<para>Detect whitespaces.</para>
<programlisting>&lt;DetectSpaces (common attributes) /&gt;</programlisting>

<para>This rule has no specific attributes.</para>
<para>Use this rule if you know that there can be several whitespaces ahead,
for example in the beginning of indented lines. This rule will skip all
whitespace at once, instead of testing multiple rules and skipping one at a
time due to no match.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>DetectIdentifier</term>
<listitem>
<para>Detect identifier strings (as the regular expression:
<userinput>[a-zA-Z_][a-zA-Z0-9_]*</userinput>).</para>
<programlisting>&lt;DetectIdentifier (common attributes) /&gt;</programlisting>

<para>This rule has no specific attributes.</para>
<para>Use this rule to skip a string of word characters at once, rather than
testing with multiple rules and skipping one at a time due to no match.</para>
</listitem>
</varlistentry>

</variablelist>
</sect3>

<sect3>
<title>Tips &amp; Tricks</title>

<itemizedlist>
<para>Once you have understood how the context switching works it will be
easy to write highlight definitions. Though you should carefully check what
rule you choose in what situation. Regular expressions are very mighty, but
they are slow compared to the other rules. So you may consider the following
tips.
</para>

<listitem>
<para>Regular expressions are easy to use but often there is another much
faster way to achieve the same result. Consider you only want to match
the character <userinput>'#'</userinput> if it is the first character in the
line. A regular expression based solution would look like this:
<programlisting>&lt;RegExpr attribute=&quot;Macro&quot; context=&quot;macro&quot; String=&quot;^\s*#&quot; /&gt;</programlisting>
You can achieve the same much faster in using:
<programlisting>&lt;DetectChar attribute=&quot;Macro&quot; context=&quot;macro&quot; char=&quot;#&quot; firstNonSpace=&quot;true&quot; /&gt;</programlisting>
If you want to match the regular expression <userinput>'^#'</userinput> you
can still use <userinput>DetectChar</userinput> with the attribute <userinput>column=&quot;0&quot;</userinput>.
The attribute <userinput>column</userinput> counts characters, so a tabulator is only one character.
</para>
</listitem>
<listitem>
<para>In <userinput>RegExpr</userinput> rules, use the attribute <userinput>column="0"</userinput> if the pattern
<userinput>^PATTERN</userinput> will be used to match text at the beginning of a line.
This improves performance, as it will avoid looking for matches in the rest of the columns.</para>
</listitem>
<listitem>
<para>In regular expressions, use non-capturing groups <userinput>(?:PATTERN)</userinput> instead of
capturing groups <userinput>(PATTERN)</userinput>, if the captures will not be used in the same regular
expression or in dynamic rules. This avoids storing captures unnecessarily.</para>
</listitem>
<listitem>
<para>You can switch contexts without processing characters. Assume that you
want to switch context when you meet the string <userinput>*/</userinput>, but
need to process that string in the next context. The below rule will match, and
the <userinput>lookAhead</userinput> attribute will cause the highlighter to
keep the matched string for the next context.
<programlisting>&lt;StringDetect attribute=&quot;Comment&quot; context=&quot;#pop&quot; String=&quot;*/&quot; lookAhead=&quot;true&quot; /&gt;</programlisting>
</para>
</listitem>
<listitem>
<para>Use <userinput>DetectSpaces</userinput> if you know that many whitespaces occur.</para>
</listitem>
<listitem>
<para>Use <userinput>DetectIdentifier</userinput> instead of the regular expression <userinput>'[a-zA-Z_]\w*'</userinput>.</para>
</listitem>
<listitem>
<para>Use default styles whenever you can. This way the user will find a familiar environment.</para>
</listitem>
<listitem>
<para>Look into other &XML; files to see how other people implement tricky rules.</para>
</listitem>
<listitem>
<para>You can validate every &XML; file by using the command
<command>validatehl.sh mySyntax.xml</command>.
The file <filename>validatehl.sh</filename> uses <filename>language.xsd</filename> which are both available in <ulink url="https://commits.kde.org/syntax-highlighting?path=data/schema">Syntax
Highlighting repository</ulink>.
</para>
</listitem>
<listitem>
<para>If you repeat complex regular expression very often you can use
<emphasis>ENTITIES</emphasis>. Example:</para>
<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE language
[
        &lt;!ENTITY myref    "[A-Za-z_:][\w.:_-]*"&gt;
]&gt;
</programlisting>
<para>Now you can use <emphasis>&amp;myref;</emphasis> instead of the regular
expression.</para>
</listitem>
<listitem>
<para>On Kate Editor, you can reload syntaxes using the built-in command line
(<userinput>F7</userinput> shortcut by default) and the <command>reload-highlighting</command>
command.</para>
</listitem>
<listitem>
<para>You can use the command-line utility named <userinput>ksyntaxhighlighter6</userinput>
(<userinput>kate-syntax-highlighter</userinput> on older versions) to test a
syntax and display the style and regions associated with each part of a text.</para>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="ksyntaxhighlighter6-trace-format.png"/></imageobject>
<textobject><phrase>Result of <command>ksyntaxhighlighter6 --output-format=ansi --syntax-trace=format test.cpp</command>.</phrase></textobject>
<caption><para>Result of <command>ksyntaxhighlighter6 --output-format=ansi --syntax-trace=format test.cpp</command>.</para>
</caption>
</mediaobject>

<para>Use <command>ksyntaxhighlighter6 -h</command> for more options.</para>
</listitem>
</itemizedlist>
</sect3>

</sect2>

</sect1>


<sect1 id="color-themes">
<title>Working with Color Themes</title>

<sect2 id="color-themes-overview">

<title>Overview</title>

<para>Color themes define the colors of the
<link linkend="kate-part">text editing area</link> and the
<link linkend="highlight">syntax highlighting</link>. A color
theme encompasses the following:
<itemizedlist>
<listitem><para>The text style, used for syntax highlighting through the
<emphasis>default styles attributes</emphasis>. For example, the text
color and the selected text color.</para></listitem>
<listitem><para>The background of the text editing area, including the text
selection and the current line.</para></listitem>
<listitem><para>The icon border of the text area: their background, the separator line,
the line numbers, the line word wrap markers, the modified line marks and
the code folding.</para></listitem>
<listitem><para>Text decorators such as the search markers, the indentation and tab/space
line marks, the bracket matching and the spell checking.</para></listitem>
<listitem><para>Bookmarks and snippets.</para></listitem>
</itemizedlist>
</para>

<para>To avoid confusion, the following is out of scope:
<itemizedlist>
<listitem><para>The font type and the font size.</para></listitem>
<listitem><para>The colors of the text editing application, such as the scroll bar map, the menus,
the tab bar, the window color, etc. In &kde; applications, like &kate; or &kdevelop;, these colors
are defined by the <userinput>&kde; &plasma; global color scheme</userinput>, which are set in
the <ulink url="help:/kcontrol/colors/"><quote>Colors</quote> module in &systemsettings;</ulink>
or from the application itself in the menu
<menuchoice><guimenu>Settings</guimenu><guisubmenu>Color Scheme</guisubmenu></menuchoice>.
</para></listitem>
</itemizedlist>
</para>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="breeze-color-theme-preview.png"/></imageobject>
<textobject><phrase><quote>Breeze Light</quote> and <quote>Breeze Dark</quote> color themes
with the <quote>C++</quote> syntax highlighting.</phrase>
</textobject>
<caption><para><quote>Breeze Light</quote> and <quote>Breeze Dark</quote> color themes
with the <quote>C++</quote> syntax highlighting.</para>
</caption>
</mediaobject>

</sect2>

<sect2 id="color-themes-ksyntaxhighlighting">

<title>The KSyntaxHighlighting Color Themes</title>

<para>The <ulink url="https://api.kde.org/frameworks/syntax-highlighting/html/">KSyntaxHighlighting</ulink>
framework, which is the <link linkend="highlight">syntax highlighting</link> engine,
is the library that <userinput>provides and manages the color themes</userinput>.
This is part of &kde; &frameworks; and is used in &kde; text editors such as
<ulink url="https://apps.kde.org/en/kate">&kate;</ulink>,
<ulink url="https://apps.kde.org/en/kwrite">&kwrite;</ulink>,
<ulink url="https://apps.kde.org/en/kile">&kile;</ulink> and
<ulink url="https://apps.kde.org/en/kdevelop">&kdevelop;</ulink>.
This dependency looks like the following:</para>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="kf5-ksyntaxhighlighting.png"/></imageobject>
<textobject><phrase>Dependence of &kde; &frameworks; 5 libraries on text editors.</phrase></textobject>
<caption><para>Dependence of &kde; &frameworks; libraries on text editors.</para>
</caption>
</mediaobject>

<para>KSyntaxHighlighting includes a variety of built-in themes which are displayed on
the <ulink url="https://kate-editor.org/themes/"><quote>Color Themes</quote> page of
the Kate editor website</ulink>.</para>

<para>The <ulink url="https://api.kde.org/frameworks/ktexteditor/html/">KTextEditor</ulink>
framework, which is the text editing engine, provides a user interface for creating and editing
color themes, including a tool for importing and exporting themes. This is the simplest way to
create and edit them, you can access it from the
<link linkend="config-dialog"><quote>Configure</quote> dialog</link> of the text editor.
More details in <xref linkend="color-themes-gui"/>.</para>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="color-themes-gui-breeze-dark-default-text-styles.png"/></imageobject>
<textobject><phrase>The &GUI; to manage color themes in &kate;'s settings.</phrase></textobject>
<caption><para>The &GUI; to manage color themes in &kate;'s settings.</para>
</caption>
</mediaobject>

<para>It is important to mention that, in the &kde; text editors like &kate; or &kdevelop;,
the KSyntaxHighlighting color themes are used
<ulink url="https://kate-editor.org/post/2020/2020-09-13-kate-color-themes-5.75/">since
&kde; &frameworks; 5.75</ulink>, released on October 10, 2020. Previously, &kate;'s color
schemes (KConfig based schema config) were used and are now deprecated. However, it is
possible to convert the old &kate; schemes to the KSyntaxHighlighting color themes.
The <ulink url="https://invent.kde.org/frameworks/syntax-highlighting">KSyntaxHighlighting
repository</ulink> includes the <userinput>utils/kateschema_to_theme_converter.py</userinput>
script and the <userinput>utils/schema-converter/</userinput> utility for that purpose.
</para>

</sect2>

<sect2 id="color-themes-json">

<title>The Color Themes &JSON; Format</title>

<sect3 id="color-themes-json-overview">

<title>Overview</title>

<para>Color themes are stored in &JSON; format files, with the
<userinput>.theme</userinput> extension.</para>

<para>In the <ulink url="https://invent.kde.org/frameworks/syntax-highlighting">
KSyntaxHighlighting source code</ulink>, the &JSON; files of built-in themes
are located in the <userinput>data/themes/</userinput> directory.
Note that in text editors, the built-in themes are compiled into the
KSyntaxHighlighting library, therefore, the way to access them is through the
source code or by <link linkend="color-themes-gui-import-export">exporting them
from the &GUI; to manage themes of KTextEditor</link>.</para>

<para>It is also possible to easily add additional or custom themes, which are
loaded from the file system. User-customized theme files are located in the
<filename class="directory">org.kde.syntax-highlighting/themes/</filename>
directory in your user folder, which you can find with the command
<userinput><command>qtpaths</command><option> --paths GenericDataLocation</option></userinput>
and are commonly <filename class="directory"><envar>$HOME</envar>/.local/share/</filename>
and <filename class="directory">/usr/share/</filename>.
</para>

<para>In Flatpak and Snap packages, the above directory will not work
as the data location is different for each application.
In a Flatpak application, the location of custom theme files is usually
<filename class="directory"><envar>$HOME</envar>/.var/app/<replaceable>flatpak-package-name</replaceable>/data/org.kde.syntax-highlighting/themes/</filename>
and in a Snap application that location is
<filename class="directory"><envar>$HOME</envar>/snap/<replaceable>snap-package-name</replaceable>/current/.local/share/org.kde.syntax-highlighting/themes/</filename>.
</para>

<para>On &Windows; these files are located
<filename>%USERPROFILE%&#92;AppData&#92;Local&#92;org.kde.syntax-highlighting&#92;themes</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to
<filename>C:&#92;Users&#92;<replaceable>user-name</replaceable></filename>.</para>

<para>In summary, for most configurations the custom themes directory is as follows:</para>

<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>For local user</entry>
<entry><filename class="directory"><envar>$HOME</envar>/.local/share/org.kde.syntax-highlighting/themes/</filename></entry>
</row>
<row>
<entry>For all users</entry>
<entry><filename class="directory">/usr/share/org.kde.syntax-highlighting/themes/</filename></entry>
</row>
<row>
<entry>For Flatpak packages</entry>
<entry><filename class="directory"><envar>$HOME</envar>/.var/app/<replaceable>flatpak-package-name</replaceable>/data/org.kde.syntax-highlighting/themes/</filename></entry>
</row>
<row>
<entry>For Snap packages</entry>
<entry><filename class="directory"><envar>$HOME</envar>/snap/<replaceable>snap-package-name</replaceable>/current/.local/share/org.kde.syntax-highlighting/themes/</filename></entry>
</row>
<row>
<entry>On &Windows;</entry>
<entry><filename class="directory">%USERPROFILE%&#92;AppData&#92;Local&#92;org.kde.syntax-highlighting&#92;themes</filename></entry>
</row>
<row>
<entry>On &macOS;</entry>
<entry><filename class="directory"><envar>$HOME</envar>/Library/Application Support/org.kde.syntax-highlighting/themes/</filename></entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>If multiple theme files exist with the same name, the file with the highest <userinput>revision</userinput> will be loaded.
</para>

</sect3>

<sect3 id="color-themes-json-basic">

<title>The &JSON; Structure</title>

<para>The structure of a &JSON; file is explained on
<ulink url="https://www.json.org">their website</ulink>.
Basically, a &JSON; format file consists of:
<itemizedlist>
<listitem><para>Collections of key/value pairs, separated by commas and grouped in
<userinput>{ }</userinput> which we will call <quote>objects</quote>.</para></listitem>
<listitem><para>Ordered lists of values, separated by commas and grouped in
<userinput>[ ]</userinput> which we will call <quote>array</quote>.</para></listitem></itemizedlist>
</para>

<para>The nomenclature <quote>key</quote>, <quote>value</quote>, <quote>object</quote>
and <quote>array</quote> will be used in this article. If this is your first time working
with &JSON; files, understanding them is as simple as looking at the examples below.
</para>

</sect3>

<sect3 id="color-themes-json-root">

<title>Main Sections of the &JSON; Color Theme Files</title>

<para>The root object of the color theme &JSON; file contains the following
schema keys:</para>

<itemizedlist>
<listitem><para><userinput>metadata</userinput>: It is mandatory. The value
is an object with the theme's metadata, such as name, revision and license.</para>
<para>This is detailed in <xref linkend="color-themes-json-metadata"/>.</para>
</listitem>

<listitem><para><userinput>editor-colors</userinput>: It is mandatory. The
value is an object with the colors of the text editing area, such as the
background, the icon border and the text decoration.</para>
<para>This is detailed in <xref linkend="color-themes-editor-colors"/>.</para>
</listitem>

<listitem><para><userinput>text-styles</userinput>: It is mandatory. The value
is an object with the <emphasis>default text style</emphasis> attributes of
the syntax highlighting. Each attribute defines its <emphasis>text color</emphasis>,
its <emphasis>selected text color</emphasis>, or whether it <emphasis>bold</emphasis>
or <emphasis>italic</emphasis>, for example. The text styles can be referenced
from <link linkend="kate-highlight-default-styles">the attributes of the syntax
definition &XML; files</link>.</para>
<para>This is detailed in <xref linkend="color-themes-text-styles"/>.</para>
</listitem>

<listitem><para><userinput>custom-styles</userinput>: It is optional. Defines
text styles for the attributes of specific syntax highlighting definitions.
For example, in a highlighting definition such as <userinput>Python</userinput>
or <userinput>Markdown</userinput> you can specify a different text style that
overrides the default defined in <userinput>text-styles</userinput>.</para>
<para>This is detailed in <xref linkend="color-themes-custom-styles"/>.</para>
</listitem>
</itemizedlist>

<para>The &JSON; language does not support comments. However, you can use the
optional key <userinput>_comments</userinput> in the root object to write comments,
for example, if you are adapting an existing theme you can put the URL of the
original repository. The most practical way is to use an array of strings.
</para>

<para>Below is an example file for the <quote>Breeze Light</quote> theme.
You can notice that, to avoid the example being too large, the
<userinput>editor-colors</userinput> and <userinput>text-styles</userinput>
objects do not contain all the required keys. You can see the full archive of
<ulink url="https://invent.kde.org/frameworks/syntax-highlighting/-/blob/master/data/themes/breeze-light.theme">
the <quote>Breeze Light</quote> theme in the KSyntaxHighlighting repository</ulink>.
</para>

<programlisting>
{
    "_comments": [
        "This is a comment.",
        "If this theme is an adaptation of another, put the link to the original repository."
    ],
    "metadata": {
        "name" : "Breeze Light",
        "revision" : 5,
        "copyright": [
            "SPDX-FileCopyrightText: 2016 Volker Krause &lt;vkrause@kde.org&gt;",
            "SPDX-FileCopyrightText: 2016 Dominik Haumann &lt;dhaumann@kde.org&gt;"
        ],
        "license": "SPDX-License-Identifier: MIT"
    },
    "editor-colors": {
        "BackgroundColor" : "#ffffff",
        "CodeFolding" : "#94caef",
        "BracketMatching" : "#ffff00",
        "CurrentLine" : "#f8f7f6",
        "IconBorder" : "#f0f0f0",
        "IndentationLine" : "#d2d2d2",
        "LineNumbers" : "#a0a0a0",
        "CurrentLineNumber" : "#1e1e1e",
        <replaceable>The other editor color keys...</replaceable>

    },
    "text-styles": {
        "Normal" : {
            "text-color" : "#1f1c1b",
            "selected-text-color" : "#ffffff",
            "bold" : false,
            "italic" : false,
            "underline" : false,
            "strike-through" : false
        },
        "Keyword" : {
            "text-color" : "#1f1c1b",
            "selected-text-color" : "#ffffff",
            "bold" : true
        },
        "Function" : {
            "text-color" : "#644a9b",
            "selected-text-color" : "#452886"
        },
        "Variable" : {
            "text-color" : "#0057ae",
            "selected-text-color" : "#00316e"
        },
        <replaceable>The other text style keys...</replaceable>

    },
    "custom-styles": {
        "ISO C++": {
            "Data Type": {
                "bold": true,
                "selected-text-color": "#009183",
                "text-color": "#00b5cf"
            },
            "Keyword": {
                "text-color": "#6431b3"
            }
        },
        "YAML": {
            "Attribute": {
                "selected-text-color": "#00b5cf",
                "text-color": "#00b5cf"
            }
        }
    }
}
</programlisting>

</sect3>

<sect3 id="color-themes-json-metadata">

<title>Metadata</title>

<para>The &JSON; object of the <userinput>metadata</userinput> key contains
relevant information on the theme. This object has the following keys:

<itemizedlist>
<listitem><para><userinput>name</userinput>: It is a <emphasis>string</emphasis>
sets the name of the language. It appears in the menus and dialogs afterwards.
It is mandatory.</para></listitem>

<listitem><para><userinput>revision</userinput>: It is an
<emphasis>integer</emphasis> number that specifies the current revision of the
theme file. Whenever you update a color theme file, make sure to increase this
number. It is mandatory.</para></listitem>

<listitem><para><userinput>license</userinput>: It is a
<emphasis>string</emphasis> that defines the license of the theme, using the
identifier <userinput>SPDX-License-Identifier</userinput> from the standard
<ulink url="https://spdx.dev/">SPDX license communication format</ulink>.
It is optional.</para>
<para>You can see the full list of SPDX license identifiers
<ulink url="https://spdx.org/licenses/">here</ulink>.</para></listitem>

<listitem><para><userinput>copyright</userinput>: It is an <emphasis>array</emphasis>
of <emphasis>strings</emphasis> that specifies the authors of the theme, using
the identifier <userinput>SPDX-FileCopyrightText</userinput> from the standard
<ulink url="https://spdx.dev/">SPDX license communication format</ulink>.
It is optional.</para></listitem>
</itemizedlist>
</para>

<programlisting>
"metadata": {
    "name" : "Breeze Light",
    "revision" : 5,
    "copyright": [
        "SPDX-FileCopyrightText: 2016 Volker Krause &lt;vkrause@kde.org&gt;",
        "SPDX-FileCopyrightText: 2016 Dominik Haumann &lt;dhaumann@kde.org&gt;"
    ],
    "license": "SPDX-License-Identifier: MIT"
}
</programlisting>

</sect3>

</sect2>

<sect2 id="color-themes-editing">

<title>Colors in Detail</title>

<para>This section details all the available color attributes and available
color settings.</para>

<sect3 id="color-themes-editor-colors">

<title>Editor Colors</title>

<para>Corresponds to the colors of the <link linkend="kate-part">text editing area</link>.</para>

<para>In the <link linkend="color-themes-json">&JSON; theme file</link>, the respective key
<userinput>editor-colors</userinput> has as value an <emphasis>object</emphasis> where each
key references an attribute color of the text editor. Here, <userinput>all available keys
are mandatory</userinput>, their values are <userinput>strings</userinput> with hexadecimal
color codes, like <quote>#00B5CF</quote>.
</para>

<para>In <link linkend="color-themes-gui">the &GUI; to manage themes of KTextEditor</link>,
these attributes can be modified in the <userinput><guilabel>Colors</guilabel></userinput> tab.
</para>

<para>The available keys are the following; the keys used in the
<link linkend="color-themes-json">&JSON; file</link> are listed in <emphasis>bold</emphasis>,
the names used in the <link linkend="color-themes-gui">&GUI;</link> are shown in parentheses.
</para>

<variablelist>

<varlistentry id="variable-prefcolors-colors-text-background">
<term><guilabel>Editor Background Colors</guilabel></term>
<listitem>

<variablelist>

<varlistentry id="variable-pref-colors-normal-text">
<term><userinput>BackgroundColor</userinput> (<guilabel>Text Area</guilabel>)</term>
<listitem><para>This is the default background for the editor area, it will be
the dominant color on the editor area.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-BackgroundColor.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry id="variable-pref-colors-selected-text">
<term><userinput>TextSelection</userinput> (<guilabel>Selected Text</guilabel>)</term>
<listitem><para>This is the background for selected text.
</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-TextSelection.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry id="variable-pref-colors-current-line">
<term><userinput>CurrentLine</userinput> (<guilabel>Current Line</guilabel>)</term>
<listitem><para>Set the color for the current line. Setting this a bit different
from the Normal text background helps to keep focus on the current line.
</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-CurrentLine.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry id="variable-pref-colors-search-highlight">
<term><userinput>SearchHighlight</userinput> (<guilabel>Search Highlight</guilabel>)</term>
<listitem><para>Set the color for the text that matches your last search.
</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-SearchHighlight.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry id="variable-pref-colors-replace-highlight">
<term><userinput>ReplaceHighlight</userinput> (<guilabel>Replace Highlight</guilabel>)</term>
<listitem><para>Set the color for the text that matches your last replace
operation.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-ReplaceHighlight.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

</variablelist>
</listitem>
</varlistentry>

<varlistentry id="variable-prefcolors-colors-icon-border">
<term><guilabel>Icon Border</guilabel></term>
<listitem>
<variablelist>

<varlistentry>
<term><userinput>IconBorder</userinput> (<guilabel>Background Area</guilabel>)</term>
<listitem><para>This color is used for the marks, line numbers and folding
marker borders in the left side of the editor view when they are displayed.
</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>LineNumbers</userinput> (<guilabel>Line Numbers</guilabel>)</term>
<listitem><para>This color is used to draw the line numbers on the left side of
the view when displayed.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>CurrentLineNumber</userinput> (<guilabel>Current Line Number</guilabel>)</term>
<listitem><para>This color is used to draw the line number of the current line,
on the left side of the view when displayed. Setting this a bit different from
<quote>LineNumbers</quote> helps to keep focus on the current line.
</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>Separator</userinput> (<guilabel>Separator</guilabel>)</term>
<listitem><para>This color is used to draw the vertical line that separates the
icon border from the background of the text area.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-IconBorder.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>WordWrapMarker</userinput> (<guilabel>Word Wrap Marker</guilabel>)</term>
<listitem><para>This color is used to draw a pattern to the left of dynamically
wrapped lines when those are aligned vertically, as well as for the static word
wrap marker.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-WordWrapMarker.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>CodeFolding</userinput> (<guilabel>Code Folding</guilabel>)</term>
<listitem><para>This color is used to highlight the section of code that would
be folded when you click on the code folding arrow to the left of a document.
For more information, see
<link linkend="advanced-editing-tools-code-folding">the code
folding documentation</link>.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-CodeFolding.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>ModifiedLines</userinput> (<guilabel>Modified Lines</guilabel>)</term>
<listitem><para>This color is used to highlight to the left of a document lines
that have been modified but not yet saved.  For more information, see
<xref linkend="kate-part-line-modification"/>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>SavedLines</userinput> (<guilabel>Saved Lines</guilabel>)</term>
<listitem><para>This color is used to highlight to the left of a document lines
that have been modified this session and saved.  For more information, see
<xref linkend="kate-part-line-modification"/>.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-ModifiedLines.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

</variablelist>
</listitem>
</varlistentry>

<varlistentry id="variable-prefcolors-colors-text-decorations">
<term><guilabel>Text Decorations</guilabel></term>
<listitem>
<variablelist>

<varlistentry>
<term><userinput>SpellChecking</userinput> (<guilabel>Spelling Mistake Line</guilabel>)</term>
<listitem><para>This color is used to indicate spelling mistakes.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-SpellChecking.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>TabMarker</userinput> (<guilabel>Tab and Space Markers</guilabel>)</term>
<listitem><para>This color is used to draw white space indicators, when they are
enabled.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-TabMarker.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>IndentationLine</userinput> (<guilabel>Indentation Line</guilabel>)</term>
<listitem><para>This color is used to draw a line to the left of indented blocks,
if <link linkend="appearance-general">that feature is enabled</link>.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-IndentationLine.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>BracketMatching</userinput> (<guilabel>Bracket Highlight</guilabel>)</term>
<listitem><para>This color is used to draw the background of matching brackets.
</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-BracketMatching.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

</variablelist>
</listitem>
</varlistentry>

<varlistentry id="variable-prefcolors-colors-marker-colors">
<term><guilabel>Marker Colors</guilabel></term>
<listitem>
<variablelist>

<varlistentry>
<term><userinput>MarkBookmark</userinput> (<guilabel>Bookmark</guilabel>)</term>
<listitem><para>This color is used to indicate bookmarks. Note that this color
has an opacity of 22% (and 33% for the current line) with respect to the background.
For more information, see <xref linkend="kate-part-bookmarks"/>.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-MarkBookmark.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>MarkBreakpointActive</userinput> (<guilabel>Active Breakpoint</guilabel>)</term>
<listitem><para>This color is used by the GDB plugin to indicate an active
breakpoint. Notice that this color has an opacity to the background.
For more information, see <ulink url="help:/kate/kate-application-plugin-gdb.html">the
GDB Plugin documentation</ulink>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>MarkBreakpointReached</userinput> (<guilabel>Reached Breakpoint</guilabel>)</term>
<listitem><para>This color is used by the GDB plugin to indicate a breakpoint
you have reached while debugging. Notice that this color has an opacity
to the background.
For more information, see <ulink url="help:/kate/kate-application-plugin-gdb.html">the
GDB Plugin documentation</ulink>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>MarkBreakpointDisabled</userinput> (<guilabel>Disabled Breakpoint</guilabel>)</term>
<listitem><para>This color is used by the GDB plugin to indicate an inactive
breakpoint. Notice that this color has an opacity to the background.
For more information, see <ulink url="help:/kate/kate-application-plugin-gdb.html">the
GDB Plugin documentation</ulink>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>MarkExecution</userinput> (<guilabel>Execution</guilabel>)</term>
<listitem><para>This color is used by the GDB plugin the line presently being
executed. Notice that this color has an opacity to the background.
For more information, see <ulink url="help:/kate/kate-application-plugin-gdb.html">the
GDB Plugin documentation</ulink>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>MarkWarning</userinput> (<guilabel>Warning</guilabel>)</term>
<listitem><para>This color is used by the build plugin to indicate a line that
has caused a compiler warning. Notice that this color has an opacity to the background.
For more information, see <ulink url="help:/kate/kate-application-plugin-build.html">the
Build Plugin documentation</ulink>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>MarkError</userinput> (<guilabel>Error</guilabel>)</term>
<listitem><para>This color is used by the build plugin to indicate a line that
has caused a compiler error. Notice that this color has an opacity to the background.
For more information, see <ulink url="help:/kate/kate-application-plugin-build.html">the
Build Plugin documentation</ulink>.</para></listitem>
</varlistentry>

</variablelist>
</listitem>
</varlistentry>

<varlistentry id="variable-prefcolors-colors-text-templates-snippets">
<term><guilabel>Text Templates &amp; Snippets</guilabel></term>
<listitem>
<variablelist>

<varlistentry>
<term><userinput>TemplateBackground</userinput> (<guilabel>Background</guilabel>)</term>
<listitem><para>This color is used by the &kate; Snippets plugin to mark the
background of a snippet.  For more information, see
<ulink url="help:/kate/kate-application-plugin-snippets.html">the &kate; Snippets
documentation</ulink>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>TemplatePlaceholder</userinput> (<guilabel>Editable Placeholder</guilabel>)</term>
<listitem><para>This color is used by the &kate; Snippets plugin to mark a
placeholder that you can click in to edit manually.  For more information, see
<ulink url="help:/kate/kate-application-plugin-snippets.html">the &kate; Snippets
documentation</ulink>.</para></listitem>
</varlistentry>

<varlistentry>
<term><userinput>TemplateFocusedPlaceholder</userinput> (<guilabel>Focused Editable Placeholder</guilabel>)</term>
<listitem><para>This color is used by the &kate; Snippets plugin to mark the
placeholder that you are presently editing.  For more information, see
<ulink url="help:/kate/kate-application-plugin-snippets.html">the &kate; Snippets
documentation</ulink>.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-Template.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

<varlistentry>
<term><userinput>TemplateReadOnlyPlaceholder</userinput> (<guilabel>Not Editable Placeholder</guilabel>)</term>
<listitem><para>This color is used by the &kate; Snippets plugin to mark a
placeholder that cannot be edited manually, such as one that is automatically
populated.  For more information, see
<ulink url="help:/kate/kate-application-plugin-snippets.html">the &kate; Snippets
documentation</ulink>.</para>
<mediaobject>
<imageobject><imagedata format="PNG" fileref="editor-colors-TemplateReadOnlyPlaceholder.png"/></imageobject>
<caption><para></para></caption>
</mediaobject>
</listitem>
</varlistentry>

</variablelist>
</listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3 id="color-themes-text-styles">

<title>Default Text Styles</title>

<para>The default text styles are inherited by the highlight text styles, allowing
the editor to present text in a very consistent way, for example comment text is using
the same style in almost all of the text formats that KSyntaxHighlighting can highlight.
</para>

<note>
<para>
These text styles can be referenced from the <userinput>default styles</userinput> used
in <link linkend="highlight">syntax highlighting</link> definition &XML; files, for example,
the <quote>Normal</quote> attribute is equivalent to <quote>dsNormal</quote> in the &XML; files,
and <quote>DataType</quote> is equivalent to <quote>dsDataType</quote>.
See <xref linkend="kate-highlight-default-styles"/> in the syntax highlighting documentation.
</para>
</note>

<tip>
<para>
Make sure to choose readable colors with good contrast especially in combination with
the <userinput><link linkend="color-themes-editor-colors">Editor Colors</link></userinput>.
See <xref linkend="color-themes-contrast"/>.
</para>
</tip>

<para>In the <link linkend="color-themes-json">&JSON; file</link>, the respective key
<userinput>text-styles</userinput> has as value an <emphasis>object</emphasis> where
each key corresponds to the name of a <emphasis>default text style</emphasis>, which are
equivalent to those used in the syntax highlighting definitions. Here, <userinput>all available
text style keys are mandatory</userinput>, these are listed below.
</para>

<programlisting>
"text-styles": {
    "Normal" : {
        "text-color" : "#1f1c1b",
        "selected-text-color" : "#ffffff",
        "bold" : false,
        "italic" : false,
        "underline" : false,
        "strike-through" : false
    },
    "Keyword" : {
        "text-color" : "#1f1c1b",
        "selected-text-color" : "#ffffff",
        "bold" : true
    },
    "Function" : {
        "text-color" : "#644a9b",
        "selected-text-color" : "#452886"
    },
    <replaceable>The other text style keys...</replaceable>
}
</programlisting>

<variablelist>
<varlistentry>

<term>Each key of <emphasis>default text style</emphasis> has a &JSON; object as
its value, where values such as <emphasis>color</emphasis>, <emphasis>bold</emphasis>,
<emphasis>italic</emphasis>, etc. are specified. These keys are as follows:
</term>

<listitem>

<para><userinput>text-color</userinput>: It is a <emphasis>string</emphasis> with the
text color in hexadecimal color code. This key/value is required.</para>

<para><userinput>selected-text-color</userinput>: The text color when it is selected
is generally the same value as <quote>text-color</quote>. When the text is selected,
the background is defined by the value of
<link linkend="variable-pref-colors-selected-text">TextSelection</link> in the
<link linkend="color-themes-editor-colors">Editor Colors</link>, so you must ensure that
the text has good contrast and is readable with this background. The value is a
<emphasis>string</emphasis> with a hexadecimal color code. This key/value is required.</para>

<para><userinput>bold</userinput>: It is a <emphasis>boolean</emphasis> that determines
if the text is in bold. This key is optional, the default value is <userinput>false</userinput>.</para>

<para><userinput>italic</userinput>: It is a <emphasis>boolean</emphasis> that determines
if the text is curved. This key is optional, the default value is <userinput>false</userinput>.</para>

<para><userinput>underline</userinput>: It is a <emphasis>boolean</emphasis> that determines
if the text is underlined. This key is optional, the default value is <userinput>false</userinput>.</para>

<para><userinput>strike-through</userinput>: It is a <emphasis>boolean</emphasis> that
determines if the text is strike through. This key is optional, the default value is <userinput>false</userinput>.</para>

<para><userinput>background-color</userinput>: Determines the background of the text,
used for example in alerts in comments. The value is a <emphasis>string</emphasis> with
a hexadecimal color code. This key is optional, by default there is no background.</para>

<para><userinput>selected-background-color</userinput>: Determines the background of the
text when it is selected. The value is a <emphasis>string</emphasis> with a hexadecimal
color code. This key is optional, by default there is no background.</para>

</listitem>
</varlistentry>
</variablelist>

<para>In <link linkend="color-themes-gui">the &GUI; to manage color themes of KTextEditor</link>,
these attributes can be modified in the <userinput><guilabel>Default Text Styles</guilabel></userinput>
tab. The name in the list of styles is using the style configured for the item, providing you
with an immediate preview when configuring a style. Each style lets you select common attributes
as well as foreground and background colors. To unset a background color, right-click to
use the context menu.</para>

<para>The available text style keys are the following; the keys used in the
<link linkend="color-themes-json">&JSON; file</link> are listed in <emphasis>bold</emphasis>,
the names used in the <link linkend="color-themes-gui">&GUI;</link> are shown in parentheses
if they are different.</para>

<variablelist>
<varlistentry>
<term><guilabel>Normal Text &amp; Source Code</guilabel></term>
<listitem>
<para><userinput>Normal</userinput>:
Default text style for normal text and source code without special highlighting.</para>

<para><userinput>Keyword</userinput>:
Text style for built-in language keywords.</para>

<para><userinput>Function</userinput>:
Text style for function definitions and function calls.</para>

<para><userinput>Variable</userinput>:
Text style for variables, if applicable. For instance, variables in PHP/Perl typically
start with a <userinput>$</userinput>, so all identifiers following the pattern
<userinput>$foo</userinput> are highlighted as variable.</para>

<para><userinput>ControlFlow</userinput> (<guilabel>Control Flow</guilabel>):
Text style for control flow keywords, such as <emphasis>if</emphasis>, <emphasis>then</emphasis>,
<emphasis>else</emphasis>, <emphasis>return</emphasis>, <emphasis>switch</emphasis>,
<emphasis>break</emphasis>, <emphasis>yield</emphasis>, <emphasis>continue</emphasis>, etc.</para>

<para><userinput>Operator</userinput>:
Text style for operators, such as <userinput>+</userinput>, <userinput>-</userinput>,
<userinput>*</userinput>, <userinput>/</userinput>, <userinput>%</userinput>, etc.</para>

<para><userinput>BuiltIn</userinput> (<guilabel>Built-in</guilabel>):
Text style for built-in language classes, functions and objects.</para>

<para><userinput>Extension</userinput>:
Text style for well-known extensions, such as &Qt; classes, functions/macros in C++ and
Python or boost.</para>

<para><userinput>Preprocessor</userinput>:
Text style for preprocessor statements or macro definitions.</para>

<para><userinput>Attribute</userinput>:
Text style for annotations or attributes of functions or objects, e.g.
<userinput>@override</userinput> in Java, or <userinput>__declspec(...)</userinput> and
<userinput>__attribute__((...))</userinput> in C++.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><guilabel>Numbers, Types &amp; Constants</guilabel></term>
<listitem>
<para><userinput>DataType</userinput> (<guilabel>Data Type</guilabel>):
Text style for built-in data types such as <emphasis>int</emphasis>, <emphasis>char</emphasis>,
<emphasis>float</emphasis>, <emphasis>void</emphasis>, <emphasis>u64</emphasis>, etc.</para>

<para><userinput>DecVal</userinput> (<guilabel>Decimal/Value</guilabel>):
Text style for decimal values.</para>

<para><userinput>BaseN</userinput> (<guilabel>Base-N Integer</guilabel>):
Text style for numbers with base other than 10.</para>

<para><userinput>Float</userinput> (<guilabel>Floating Point</guilabel>):
Text style for floating point numbers.</para>

<para><userinput>Constant</userinput>:
Text style for language constants and user defined constants, e.g. <emphasis>True</emphasis>,
<emphasis>False</emphasis>, <emphasis>None</emphasis> in Python or <emphasis>nullptr</emphasis>
in C/C++; or math constants like <emphasis>PI</emphasis>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><guilabel>Strings &amp; Characters</guilabel></term>
<listitem>
<para><userinput>Char</userinput> (<guilabel>Character</guilabel>):
Text style for single characters such as <userinput>'x'</userinput>.</para>

<para><userinput>SpecialChar</userinput> (<guilabel>Special Character</guilabel>):
Text style for escaped characters in strings, e.g. <quote><userinput>hello\n</userinput></quote>,
and other characters with special meaning in strings, such as substitutions or regex operators.</para>

<para><userinput>String</userinput>:
Text style for strings like <quote><userinput>hello world</userinput></quote>.</para>

<para><userinput>VerbatimString</userinput> (<guilabel>Verbatim String</guilabel>):
Text style for verbatim or raw strings like <userinput>'raw \backlash'</userinput> in
Perl, CoffeeScript, and shells, as well as <userinput>r'\raw'</userinput> in Python,
or such as HERE docs.</para>

<para><userinput>SpecialString</userinput> (<guilabel>Special String</guilabel>):
Text style for special strings, such as regular expressions in ECMAScript, the &latex; math
mode, SQL, etc.</para>

<para><userinput>Import</userinput> (<guilabel>Imports, Modules, Includes</guilabel>):
Text style for includes, imports, modules or &latex; packages.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><guilabel>Comments &amp; Documentation</guilabel></term>
<listitem>
<para><userinput>Comment</userinput>:
Text style for normal comments.</para>

<para><userinput>Documentation</userinput>:
Text style for comments that reflect API documentation, such as
<userinput>/** doxygen comments */</userinput> or <userinput>"""docstrings"""</userinput>.</para>

<para><userinput>Annotation</userinput>:
Text style for annotations in comments or documentation commands, such as
<userinput>@param</userinput> in Doxygen or JavaDoc.</para>

<para><userinput>CommentVar</userinput> (<guilabel>Comment Variable</guilabel>):
Text style that refers to variables names used in above commands in a comment, such as
<userinput>foobar</userinput> in <quote><userinput>@param foobar</userinput></quote>,
in Doxygen or JavaDoc.</para>

<para><userinput>RegionMarker</userinput> (<guilabel>Region Marker</guilabel>):
Text style for region markers, typically defined by <userinput>//BEGIN</userinput>
and <userinput>//END</userinput> in comments.</para>

<para><userinput>Information</userinput>:
Text style for information, notes and tips, such as the keyword
<userinput>@note</userinput> in Doxygen.</para>

<para><userinput>Warning</userinput>:
Text style for warnings, such as the keyword <userinput>@warning</userinput> in Doxygen.</para>

<para><userinput>Alert</userinput>:
Text style for special words in comments, such as <userinput>TODO</userinput>,
<userinput>FIXME</userinput>, <userinput>XXXX</userinput> and <userinput>WARNING</userinput>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><guilabel>Miscellaneous</guilabel></term>
<listitem>
<para><userinput>Error</userinput>:
Text style indicating error highlighting and wrong syntax.</para>

<para><userinput>Others</userinput>:
Text style for attributes that do not match any of the other default styles.</para>
</listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="color-themes-custom-styles">

<title>Custom Highlighting Text Styles</title>

<para>Here you can establish text styles for a specific syntax highlighting definition,
overriding the <userinput>default text style</userinput> described in
<link linkend="color-themes-text-styles">the previous section</link>.
</para>

<para>In the <link linkend="color-themes-json">&JSON; theme file</link>, this corresponds
to the <userinput>custom-styles</userinput> key, whose value is an <emphasis>object</emphasis>
where each subschema key corresponds to the <userinput>name of a syntax highlighting definition</userinput>.
Its value is an <emphasis>object</emphasis> where each key refers to the <userinput>style attributes
name</userinput> defined in <link linkend="kate-highlight-sections">the <userinput>itemData</userinput>
elements</link> of the syntax highlighting &XML; file, and the respective value is a sub-object with the keys
<emphasis>text-color</emphasis>, <emphasis>selected-text-color</emphasis>, <emphasis>bold</emphasis>,
<emphasis>italic</emphasis>, <emphasis>underline</emphasis>, <emphasis>strike-through</emphasis>,
<emphasis>background-color</emphasis> and <emphasis>selected-background-color</emphasis>, defined in
<link linkend="color-themes-text-styles">the previous section</link>. Each of these values are optional,
since if they are not present, the style set in <userinput>text-styles</userinput> is considered.
</para>

<para>For example, in this piece of code, the <quote>ISO C++</quote> syntax highlighting definition
has a special text style for the <quote>Type Modifiers</quote> and <quote>Standard Classes</quote>
attributes. In the corresponding &XML; file <quote>isocpp.xml</quote>, the defined attribute
<quote>Standard Classes</quote> uses the default style <userinput>BuiltIn</userinput> (or dsBuiltIn).
In this attribute, only the value of <userinput>text-color</userinput> is overwritten by the new
color <quote>#6431b3</quote>.
</para>

<programlisting>
"custom-styles": {
    "ISO C++": {
        "Standard Classes": {
            "text-color": "#6431b3"
        },
        "Type Modifiers": {
            "bold": true,
            "selected-text-color": "#009183",
            "text-color": "#00b5cf"
        }
    }
}
</programlisting>

<note>
<itemizedlist>

<listitem>
<para>You should consider that these text styles are associated with the attribute names defined
in the syntax highlighting &XML; files. If an XML file is updated and some attributes are renamed
or removed, the custom style defined in the theme will no longer apply.</para>
</listitem>

<listitem>
<para>Syntax highlighting definitions often include other definitions. For example, the
<quote>QML</quote> highlighter includes the <quote>JavaScript</quote> highlighter,
since they share functionality in highlighting.</para>
</listitem>

</itemizedlist>
</note>

<para>In <link linkend="color-themes-gui">the &GUI; to manage themes of KTextEditor</link>,
these attributes can be modified in the
<userinput><guilabel>Highlighting Text Styles</guilabel></userinput> tab.
By default, the editor preselects the highlighting of the current document. You will notice that
many highlights contain other highlights represented by groups in the style list. For example
most highlights import the <quote>Alert</quote> highlight, and many source code formats import
the <quote>Doxygen</quote> highlight.
</para>

</sect3>

</sect2>

<sect2 id="color-themes-gui">

<title>The Color Themes &GUI;</title>

<para>The simplest way to create and edit color themes is through the &GUI; within
the <link linkend="config-dialog"><quote>Configure</quote> dialog</link> provided
by <ulink url="https://api.kde.org/frameworks/ktexteditor/html/">KTextEditor</ulink>.
To access it, select <menuchoice><guimenu>Settings</guimenu>
<guimenuitem>Configure <replaceable>Application</replaceable>...</guimenuitem></menuchoice>
from the menubar in your text editor. This brings up the <guilabel>Configure</guilabel>
dialog box, there select <guilabel>Color Themes</guilabel> in the side panel.
</para>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="color-themes-gui-default-text-styles.png"/></imageobject>
<textobject><phrase>&kate;'s settings dialog box with the color theme management.</phrase></textobject>
<caption><para>&kate;'s settings dialog box with the color theme management.</para>
</caption>
</mediaobject>

<para>In this <link linkend="config-dialog">dialog</link> you can configure all the colors
in any theme you have, as well as create/copy new themes, delete them, export them to a
<userinput>.theme</userinput> file with <link linkend="color-themes-json">&JSON; format</link>
or import them from external <userinput>.theme</userinput> files. Each theme has settings
for text colors and styles.
</para>

<para>The built-in themes cannot be modified by default. To do this, you need to copy
them and give them a new name.</para>

<para>To use a theme permanently in your text editor, you must select it in the combobox
labeled <guilabel>Default theme for <replaceable>Application</replaceable></guilabel> at
the bottom of the dialog and press <guibutton>Apply</guibutton> or <guibutton>OK</guibutton>.
By default, the <userinput><guilabel>Automatic Selection</guilabel></userinput> option is
active, which chooses a more appropriate color theme according to the
<emphasis>&kde; &plasma; color scheme</emphasis> used in the text editing application;
it usually chooses between <quote>Breeze Light</quote> and <quote>Breeze Dark</quote>
if the scheme is light or dark, respectively.
</para>

<tip>
<para>
You can adjust the &kde; global color scheme in the
<ulink url="help:/kcontrol/colors/"><quote>Colors</quote> module in &systemsettings;</ulink>.
You can also change it in some applications individually such as &kate; or &kdevelop;, from the menu
<menuchoice><guimenu>Settings</guimenu><guisubmenu>Color Scheme</guisubmenu></menuchoice>.
</para>
</tip>

<sect3 id="color-themes-gui-new-theme">

<title>Create a new theme</title>

<para>To create a new theme, it is first necessary to copy an existing one. Select an existing
theme which you want to use as a base, such as <quote>Breeze Light</quote> or <quote>Breeze Dark</quote>,
and click <guibutton>Copy</guibutton>. Then write a name for the new theme.
</para>

<para>If you want to modify a built-in or read-only theme, you must first copy it under a different name.</para>

</sect3>

<sect3 id="color-themes-gui-import-export">

<title>Import or export &JSON; theme files</title>

<para>You can export a selected theme (including built-in ones) to a
<link linkend="color-themes-json">&JSON; file</link> with <userinput>.theme</userinput>
extension, with the <guibutton>Export</guibutton> button. This will open a dialog
to save the file. To add a color theme from an external
<link linkend="color-themes-json">&JSON; file</link>, just press the
<guibutton>Import</guibutton> button and select the
<userinput>.theme</userinput> file from the dialog.
</para>

<tip>
<itemizedlist>

<listitem>
<para>As <link linkend="color-themes-json-overview">mentioned above</link>, user-customized theme
files are stored in the <filename class="directory">org.kde.syntax-highlighting/themes/</filename>
directory. When you copy or create a theme, it will automatically appear there. Also, importing
or adding a theme is equivalent to copying an external <userinput>.theme</userinput> file into this
directory. KSyntaxHighlighting automatically picks up color theme files from this directory.</para>
</listitem>

<listitem>
<para>If you want to publish a theme created by you, it is essential to check the
<link linkend="color-themes-json-metadata">metadata</link> object of the
<link linkend="color-themes-json">&JSON; file</link>, adding the respective license and
checking the revision number.</para>
</listitem>

</itemizedlist>
</tip>

</sect3>

<sect3 id="color-themes-gui-editing">

<title>Editing color themes</title>

<sect4 id="prefcolors-colors">

<title>Colors</title>

<para>Here the colors of the text editing area are adjusted. These are detailed in
<xref linkend="color-themes-editor-colors"/>.</para>

</sect4>

<sect4 id="prefcolors-normal-text-styles">

<title>Default Text Styles</title>

<para>The default text styles are inherited by the highlight text styles,
allowing the editor to present text in a very consistent way, for example comment
text is using the same style in almost all of the text formats that
KSyntaxHighlighting can highlight.</para>
<para>The name in the list of styles is using the style configured for
the item, providing you with an immediate preview when configuring a style.
</para>
<para>Each style lets you select common attributes as well as foreground
and background colors. To unset a background color, right-click to use the
context menu.</para>
<para>The attributes of this area are detailed in
<xref linkend="color-themes-text-styles"/>.</para>

</sect4>

<sect4 id="prefcolors-highlighting-text-styles">

<title>Highlighting Text Styles</title>

<para>Here you can edit the text styles used by a specific highlight definition.
The editor preselects the highlight used by your current document. To work on a
different highlight, select one in the <guilabel>Highlight</guilabel> combobox
above the style list.
</para>
<para>The name in the list of styles is using the style configured for
the item, providing you with an immediate preview when configuring a style.
</para>
<para>Each style lets you select common attributes as well as foreground
and background colors. To unset a background color, right-click to use the
context menu. In addition you can see if a style is equal to the default style
used for the item, and set it to that if not.</para>
<para>You will notice that many highlights contain other highlights represented
by groups in the style list. For example most highlights import the Alert
highlight, and many source code formats imports the Doxygen highlight. Editing
colors in those groups only affects the styles when used in the edited highlight
format.
</para>

</sect4>

</sect3>

</sect2>

<sect2 id="color-themes-tips-and-tricks">

<title>Tips &amp; Tricks</title>

<sect3 id="color-themes-contrast">

<title>Contrast of Text Colors</title>

<para>An important aspect when working with color themes is to choose a text contrast
that makes it easier to read, especially in combination with the background.</para>

<para>The <userinput>Kontrast</userinput> application is a color contrast checker. It tells
you that the text color and background color combinations are readable and accessible, so
this is an excellent tool to help you create color themes.</para>

<para>You can download <userinput>Kontrast</userinput> from
<ulink url="https://apps.kde.org/en/kontrast">the &kde; Applications website</ulink>
or from <ulink url="https://flathub.org/apps/details/org.kde.kontrast">the Flatpak
package on Flathub</ulink> (only in GNU/Linux).</para>

<para>The GNOME <userinput>Contrast</userinput> application is similar. You can download
<ulink url="https://flathub.org/apps/details/org.gnome.design.Contrast">the Flatpak
package on Flathub</ulink> (only in GNU/Linux).</para>

<para>A python script in <ulink url="https://invent.kde.org/frameworks/syntax-highlighting/-/blob/master/utils/theme_contrast_checker.py?ref_type=heads">Syntax
Highlighting repository</ulink> lets you visualize all the colors in a theme,
as well as the contrast with the various backgrounds configured.</para>

</sect3>

<sect3 id="color-themes-tips-and-tricks-consistency">

<title>Suggestions of Consistency with Syntax Highlighting</title>

<para>KSyntaxHighlighting includes <ulink url="https://kate-editor.org/syntax/">more
than 300 syntax highlighting definitions</ulink>, therefore it is ideal that you
make sure your new theme looks good in all syntax highlighting definitions.
The built-in color themes have the following similarities that it is
recommended (but not required) to follow to achieve a correct display of all syntax
highlighting definitions:</para>

<itemizedlist>
<listitem><para>Use bold for the <quote>Keyword</quote> and <quote>ControlFlow</quote>
<link linkend="color-themes-text-styles">text styles</link>.</para></listitem>

<listitem><para>Do not use background color in any
<link linkend="color-themes-text-styles">text style</link>, except <quote>Alert</quote>
and <quote>RegionMarker</quote>.</para></listitem>
</itemizedlist>

<para>Most of the syntax highlighters are intended to look good on the default themes
<quote>Breeze Light</quote> and <quote>Breeze Dark</quote>, therefore, another way to
maintain consistency is to use similar colors in the
<link linkend="color-themes-text-styles">text styles</link>, like <emphasis>green</emphasis>
for <quote>Preprocessor</quote> and <quote>Others</quote>, <emphasis>blue</emphasis> for
<quote>DataType</quote> and <quote>Attribute</quote>, or <emphasis>purple</emphasis> for
<quote>Function</quote>.</para>

<para>Note that these recommendations are not mandatory when creating and publishing
a theme.</para>

</sect3>

</sect2>

</sect1>


<sect1 id="dev-scripting">
<title>Scripting with &javascript;</title>

<para>
The &kappname; editor component is easily extensible by writing scripts.
The scripting language is ECMAScript (widely known as &javascript;).
&kappname; supports two kinds of scripts: indentation and command line scripts.
</para>

<sect2 id="dev-scripting-indentation">
<title>Indentation Scripts</title>

<para>
Indentation scripts - also referred as indenters - automatically indent the
source code while typing text. As an example, after hitting the return key
the indentation level often increases.
</para>

<para>
The following sections describe step by step how to create the skeleton for a
simple indenter. As a first step, create a new <filename>*.js</filename> file
called &eg; <filename>javascript.js</filename> in the local home folder
<filename>$<envar>XDG_DATA_HOME</envar>/katepart5/script/indentation</filename>.
Therein, the environment variable <envar>XDG_DATA_HOME</envar> typically expands to
either <filename>~/.local</filename> or <filename>~/.local/share</filename>.
</para>
<para>On &Windows; these files are located in <filename>%USERPROFILE%\AppData\Local\katepart5\script\indentation</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.</para>

<sect3 id="dev-scripting-indentation-header">
<title>The Indentation Script Header</title>
<para>
The header of the file <filename>javascript.js</filename> is embedded as &JSON; at the beginning of the document as follows:

<programlisting>
var katescript = {
    "name": "JavaScript",
    "author": "Example Name &lt;example.name@some.address.org&gt;",
    "license": "BSD License",
    "revision": 1,
    "kate-version": "5.1",
    "required-syntax-style": "javascript",
    "indent-languages": ["javascript"],
    "priority": 0,
}; // kate-script-header, must be at the start of the file without comments
</programlisting>

Each entry is explained in detail now:
<itemizedlist>
<listitem><para>
<literal>name</literal> [required]: This is the indenter name that appears in the menu
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Indentation</guimenuitem></menuchoice>
and in the configuration dialog.
</para></listitem>
<listitem><para>
<literal>author</literal> [optional]: The author's name and contact information.
</para></listitem>
<listitem><para>
<literal>license</literal> [optional]: Short form of the license, such as BSD License or LGPLv3.
</para></listitem>
<listitem><para>
<literal>revision</literal> [required]: The revision of the script. This number should be increased whenever the script is modified.
</para></listitem>
<listitem><para>
<literal>kate-version</literal> [required]: Minimum required &kappname; version.
</para></listitem>
<listitem><para>
<literal>required-syntax-style</literal> [optional]: The required syntax style, which matches the specified <literal>style</literal> in syntax highlighting files. This is important for indenters that rely on specific highlight information in the document. If a required syntax style is specified, the indenter is available only when the appropriate highlighter is active. This prevents <quote>undefined behavior</quote> caused by using the indenter without the expected highlighting schema. For instance, the Ruby indenter makes use of this in the files <filename>ruby.js</filename> and <filename>ruby.xml</filename>.
</para></listitem>
<listitem><para>
<literal>indent-languages</literal> [optional]: &JSON; array of syntax styles the indenter can indent correctly, &eg;: <literal>["c++", "java"]</literal>.
</para></listitem>
<listitem><para>
<literal>priority</literal> [optional]: If several indenters are suited for a certain highlighted file, the priority decides which indenter is chosen as default indenter.
</para></listitem>
</itemizedlist>
</para>

</sect3>

<sect3 id="dev-scripting-indentation-body">
<title>The Indenter Source Code</title>
<para>
Having specified the header this section explains how the indentation scripting
itself works. The basic skeleton of the body looks like this:

<programlisting>
// required katepart js libraries, &eg; range.js if you use Range
require ("range.js");

triggerCharacters = "{}/:;";
function indent(line, indentWidth, ch)
{
    // called for each newline (ch == '\n') and all characters specified in
    // the global variable triggerCharacters. When calling <menuchoice><guimenu>Tools</guimenu><guimenuitem>Format Indentation</guimenuitem></menuchoice>
    // the variable ch is empty, i.e. ch == ''.
    //
    // see also: Scripting API
    return -2;
}
</programlisting>

The function <function>indent()</function> has three parameters:
<itemizedlist>
<listitem><para><literal>line</literal>: the line that has to be indented</para></listitem>
<listitem><para><literal>indentWidth</literal>: the indentation width in number of spaces</para></listitem>
<listitem><para><literal>ch</literal>: either a newline character (<literal>ch == '\n'</literal>), the trigger character specified in <literal>triggerCharacters</literal> or empty if the user invoked the action <menuchoice><guimenu>Tools</guimenu><guimenuitem>Format Indentation</guimenuitem></menuchoice>.</para></listitem>
</itemizedlist>
The return value of the <function>indent()</function> function specifies how
the line will be indented. If the return value is a simple integer number, it
is interpreted as follows:
<itemizedlist>
<listitem><para>return value <literal>-2</literal>: do nothing</para></listitem>
<listitem><para>return value <literal>-1</literal>: keep indentation (searches for previous non-blank line)</para></listitem>
<listitem><para>return value <literal> 0</literal>: numbers &gt;= 0 specify the indentation depth in spaces</para></listitem>
</itemizedlist>
Alternatively, an array of two elements can be returned:
<itemizedlist>
<listitem><para><literal>return [ indent, align ];</literal></para></listitem>
</itemizedlist>
In this case, the first element is the indentation depth as above with the
same meaning of the special values. However, the second element is an absolute
value representing a column for <quote>alignment</quote>. If this value is higher than the
indent value, the difference represents a number of spaces to be added after
the indentation of the first parameter. Otherwise, the second number is ignored.
Using tabs and spaces for indentation is often referred to as <quote>mixed mode</quote>.
</para>

<para>
Consider the following example: Assume using tabs to indent, and tab width is set
to 4. Here, &lt;tab&gt; represents a tab and '.' a space:
<programlisting>
1: &lt;tab&gt;&lt;tab&gt;foobar("hello",
2: &lt;tab&gt;&lt;tab&gt;......."world");
</programlisting>
When indenting line 2, the <function>indent()</function> function returns [8, 15]. As result, two
tabs are inserted to indent to column 8, and 7 spaces are added to align the
second parameter under the first, so that it stays aligned if the file is viewed
with a different tab width.
</para>

<para>
A default &kde; installation ships &kappname; with several indenters. The
corresponding &javascript; source code can be found in <filename>$<envar>XDG_DATA_DIRS</envar>/katepart5/script/indentation</filename>.</para>
<para>On &Windows; these files are located in <filename>%USERPROFILE%\AppData\Local\katepart5\script\indentation</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.
</para>

<para>
Developing an indenter requires reloading the scripts to see whether the changes
behave appropriately. Instead of restarting the application, simply switch to
the command line and invoke the command <command>reload-scripts</command>.
</para>

<para>
If you develop useful scripts please consider contributing to the &kappname; Project
by <ulink url="mailto:kwrite-devel@kde.org">contacting the mailing list</ulink>.
</para>

</sect3>
</sect2>

<sect2 id="dev-scripting-command-line">
<title>Command Line Scripts</title>

<para>
As it is hard to satisfy everyone's needs, &kappname; supports little helper tools
for quick text manipulation through the
<link linkend="advanced-editing-tools-commandline">built-in command line</link>.
For instance, the command
<command>sort</command> is implemented as a script. This section explains how to create
<filename>*.js</filename> files to extend &kappname; with arbitrary helper scripts.
</para>

<para>
Command line scripts are located in the same folder as indentation scripts.
So as a first step, create a new <filename>*.js</filename> file called
<filename>myutils.js</filename> in the local home folder
<filename>$<envar>XDG_DATA_HOME</envar>/katepart5/script/commands</filename>.
Therein, the environment variable <envar>XDG_DATA_HOME</envar> typically expands to
either <filename>~/.local</filename> or <filename>~/.local/share</filename>.</para>
<para>On &Windows; these files are located in <filename>%USERPROFILE%\AppData\Local\katepart5\script\commands</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.
</para>

<sect3 id="dev-scripting-command-line-header">
<title>The Command Line Script Header</title>
<para>
The header of each command line script is embedded in &JSON; at the beginning of the script as follows:

<programlisting>
var katescript = {
    "author": "Example Name &lt;example.name@some.address.org&gt;",
    "license": "LGPLv2+",
    "revision": 1,
    "kate-version": "5.1",
    "functions": ["sort", "moveLinesDown"],
    "actions": [
        {   "function": "sort",
            "name": "Sort Selected Text",
            "category": "Editing",
            "interactive": "false"
        },
        {   "function": "moveLinesDown",
            "name": "Move Lines Down",
            "category": "Editing",
            "shortcut": "Ctrl+Shift+Down",
            "interactive": "false"
        }
    ]
}; // kate-script-header, must be at the start of the file without comments
</programlisting>

Each entry is explained in detail now:
<itemizedlist>
<listitem><para><literal>author</literal> [optional]: The author's name and contact information.</para></listitem>
<listitem><para><literal>license</literal> [optional]: Short form of the license, such as BSD License or LGPLv2.</para></listitem>
<listitem><para><literal>revision</literal> [required]: The revision of the script. This number should be increased whenever the script is modified.</para></listitem>
<listitem><para><literal>kate-version</literal> [required]: Minimum required &kappname; version.</para></listitem>
<listitem><para><literal>functions</literal> [required]: &JSON; array of commands in the script.</para></listitem>
<listitem><para><literal>actions</literal> [optional]: &JSON; Array of &JSON; objects that defines the actions that appear in the application menu. Detailed information is provided in the section <link linkend="advanced-editing-tools-commandline">Binding Shortcuts</link>.</para></listitem>
</itemizedlist>
</para>

<para>
Since the value of <literal>functions</literal> is a &JSON; array, a single script is able to contain an arbitrary number
of command line commands. Each function is available through &kappname;'s
<link linkend="advanced-editing-tools-commandline">built-in command line</link>.
</para>
</sect3>

<sect3 id="dev-scripting-command-line-body">
<title>The Script Source Code</title>

<para>
All functions specified in the header have to be implemented in the script.
For instance, the script file from the example above needs to implement the two
functions <command>sort</command> and <command>moveLinesDown</command>.
All functions have the following syntax:

<programlisting>
// required katepart js libraries, &eg; range.js if you use Range
require ("range.js");

function &lt;name&gt;(arg1, arg2, ...)
{
    // ... implementation, see also: Scripting API
}
</programlisting>
</para>

<para>
Arguments in the command line are passed to the function as
<parameter>arg1</parameter>, <parameter>arg2</parameter>, &etc;
In order to provide documentation for each command, simply implement the
'<function>help</function>' function as follows:

<programlisting>
function help(cmd)
{
    if (cmd == "sort") {
        return i18n("Sort the selected text.");
    } else if (cmd == "...") {
        // ...
    }
}
</programlisting>

Executing <command>help sort</command> in the command line then calls this help function with
the argument <parameter>cmd</parameter> set to the given command, &ie;
<parameter>cmd == "sort"</parameter>. &kappname; then presents the returned text as
documentation to the user. Make sure to
<link linkend="dev-scripting-api-i18n">translate the strings</link>.
</para>

<para>
Developing a command line script requires reloading the scripts to see whether
the changes behave appropriately. Instead of restarting the application, simply
switch to the command line and invoke the command <command>reload-scripts</command>.
</para>

<sect4 id="dev-scripting-command-line-shortcuts">
<title>Binding Shortcuts</title>
<para>In order to make the scripts accessible in the application menu and assign shortcuts, the script needs to provide an appropriate
script header. In the above example, both functions <literal>sort</literal> and <literal>moveLinesDown</literal> appear in the menu
due to the following part in the script header:
<programlisting>
var katescript = {
    ...
    "actions": [
        {   "function": "sort",
            "name": "Sort Selected Text",
            "icon": "",
            "category": "Editing",
            "interactive": "false"
        },
        {   "function": "moveLinesDown",
            "name": "Move Lines Down",
            "icon": "",
            "category": "Editing",
            "shortcut": "Ctrl+Shift+Down",
            "interactive": "false"
        }
    ]
};
</programlisting>
The fields for one action are as follows:
<itemizedlist>
<listitem><para><literal>function</literal> [required]: The function that should appear in the menu <menuchoice><guimenu>Tools</guimenu> <guisubmenu>Scripts</guisubmenu></menuchoice>.</para></listitem>
<listitem><para><literal>name</literal> [required]: The text appears in the script menu.</para></listitem>
<listitem><para><literal>icon</literal> [optional]: The icon appears next to the text in the menu. All &kde; icon names can be used here.</para></listitem>
<listitem><para><literal>category</literal> [optional]: If a category is specified, the script appears in a submenu.</para></listitem>
<listitem><para><literal>shortcut</literal> [optional]: The shortcut given here is the default shortcut. Example: <literal>Ctrl+Alt+t</literal>. See the <ulink url="https://doc.qt.io/qt-5/qt.html#Key-enum">&Qt; documentation</ulink> for further details.</para></listitem>
<listitem><para><literal>interactive</literal> [optional]: If the script needs user input in the command line, set this to <literal>true</literal>.</para></listitem>
</itemizedlist>
</para>

<para>
If you develop useful scripts please consider contributing to the &kappname; Project
by <ulink url="mailto:kwrite-devel@kde.org">contacting the mailing list</ulink>.
</para>

</sect4>
</sect3>
</sect2>

<sect2 id="dev-scripting-api">
<title>Scripting API</title>

<para>
The scripting API presented here is available to all scripts, &ie; indentation
scripts and command line commands.
The <classname>Cursor</classname> and <classname>Range</classname> classes are provided by library files in <filename>$<envar>XDG_DATA_DIRS</envar>/katepart5/libraries</filename>.
If you want to use them in your script, which needs to use some of the <classname>Document</classname> or <classname>View</classname> functions, please include the necessary library by using:

<programlisting>
// required katepart js libraries, &eg; range.js if you use Range
require ("range.js");
</programlisting>
</para>

<para>
To extend the standard scripting API with your own functions and prototypes simply
create a new file in &kde;'s local configuration folder
<filename>$<envar>XDG_DATA_HOME</envar>/katepart5/libraries</filename> and include it into your script using:

<programlisting>
require ("myscriptnamehere.js");
</programlisting>

</para>

<para>On &Windows; these files are located in <filename>%USERPROFILE%\AppData\Local\katepart5\libraries</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.</para>

<para>
To extend existing prototypes like <classname>Cursor</classname> or
<classname>Range</classname>, the recommended way is to
<emphasis>not</emphasis> modify the global <filename>*.js</filename> files.
Instead, change the <classname>Cursor</classname> prototype in &javascript; after the <filename>cursor.js</filename> is included into your
script via <literal>require</literal>.
</para>

<sect3 id="dev-scripting-api-prototypes">
<title>Cursors and Ranges</title>

<para>
As &kappname; is a text editor, all the scripting API is based on cursors and
ranges whenever possible. A Cursor is a simple <literal>(line, column)</literal>
tuple representing a text position in the document. A Range spans text from a
starting cursor position to an ending cursor position. The API is explained in
detail in the next sections.
</para>

<sect4 id="dev-scripting-api-cursors">
<title>The Cursor Prototype</title>

<variablelist><varlistentry>
<term><synopsis>
Cursor();
</synopsis></term>
<listitem><para>
Constructor. Returns a Cursor at position <literal>(0, 0)</literal>.</para>
<para>Example: <function>var cursor = new Cursor();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Returns a Cursor at position (line, column).
</para>
<para>Example: <function>var cursor = new Cursor(3, 42);</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Copy constructor. Returns a copy of the cursor <replaceable>other</replaceable>.
</para>
<para>Example: <function>var copy = new Cursor(other);</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor Cursor.clone();
</synopsis></term>
<listitem><para>
Returns a clone of the cursor.</para>
<para>Example: <function>var clone = cursor.clone();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor.setPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Sets the cursor position to <replaceable>line</replaceable> and <replaceable>column</replaceable>.</para>
<para>
Since: &kde; 4.11
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Cursor.isValid();
</synopsis></term>
<listitem><para>
Check whether the cursor is valid. The cursor is invalid, if line and/or
column are set to <literal>-1</literal>.
</para>
<para>
Example: <function>var valid = cursor.isValid();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor Cursor.invalid();
</synopsis></term>
<listitem><para>
Returns a new invalid cursor located at <literal>(-1, -1)</literal>.
</para>
<para>Example: <function>var invalidCursor = cursor.invalid();</function>
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
int Cursor.compareTo(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Compares this cursor to the cursor <replaceable>other</replaceable>. Returns
<itemizedlist>
<listitem><para><literal>-1</literal>, if this cursor is located before the cursor <replaceable>other</replaceable>,</para></listitem>
<listitem><para><literal>0</literal>, if both cursors equal and</para></listitem>
<listitem><para><literal>+1</literal>, if this cursor is located after the cursor <replaceable>other</replaceable>.</para></listitem>
</itemizedlist>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Cursor.equals(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this cursor and the cursor <replaceable>other</replaceable> are
equal, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String Cursor.toString();
</synopsis></term>
<listitem><para>
Returns the cursor as a string of the form <quote><literal>Cursor(line, column)</literal></quote>.
</para></listitem>
</varlistentry></variablelist>

</sect4>


<sect4 id="dev-scripting-api-ranges">
<title>The Range Prototype</title>

<variablelist><varlistentry>
<term><synopsis>
Range();
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range()</literal> returns a Range at (0, 0) - (0, 0).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range(<parameter>Cursor <replaceable>start</replaceable></parameter>, <parameter>Cursor <replaceable>end</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range(<replaceable>start</replaceable>, <replaceable>end</replaceable>)</literal> returns the Range (<replaceable>start</replaceable>, <replaceable>end</replaceable>).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>int <replaceable>startColumn</replaceable></parameter>, <parameter>int <replaceable>endLine</replaceable></parameter>, <parameter>int <replaceable>endColumn</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range(<replaceable>startLine</replaceable>, <replaceable>startColumn</replaceable>, <replaceable>endLine</replaceable>, <replaceable>endColumn</replaceable>)</literal>
returns the Range from (<replaceable>startLine</replaceable>, <replaceable>startColumn</replaceable>) to (<replaceable>endLine</replaceable>, <replaceable>endColumn</replaceable>).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Copy constructor. Returns a copy of Range <replaceable>other</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range Range.clone();
</synopsis></term>
<listitem><para>
Returns a clone of the range.
</para>
<para>Example: <function>var clone = range.clone();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.isEmpty();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the start and end cursors are equal.
</para>
<para>Example: <function>var empty = range.isEmpty();</function>
</para>
<para>
Since: &kde; 4.11
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.isValid();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if both start and end cursor are valid, otherwise <literal>false</literal>.
</para>
<para>Example: <function>var valid = range.isValid();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range Range.invalid();
</synopsis></term>
<listitem><para>
Returns the Range from (-1, -1) to (-1, -1).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.contains(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range contains the cursor position, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.contains(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range contains the Range <replaceable>other</replaceable>,
otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.containsColumn(<parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>column</replaceable> is in the half open interval
<literal>[start.column, end.column)</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.containsLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>line</replaceable> is in the half open interval
<literal>[start.line, end.line)</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.overlaps(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range and the range <replaceable>other</replaceable> share
a common region, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.overlapsLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>line</replaceable> is in the interval
<literal>[start.line, end.line]</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.overlapsColumn(<parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>column</replaceable> is in the interval
<literal>[start.column, end.column]</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.onSingleLine();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the range starts and ends at the same line,
&ie; if <replaceable>Range.start.line == Range.end.line</replaceable>.
</para>
<para>
Since: &kde; 4.9
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.equals(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range and the Range <replaceable>other</replaceable> are
equal, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String Range.toString();
</synopsis></term>
<listitem><para>
Returns the range as a string of the form <quote><literal>Range(Cursor(line, column), Cursor(line, column))</literal></quote>.
</para></listitem>
</varlistentry></variablelist>

</sect4>
</sect3>

<sect3 id="dev-scripting-api-global">
<title>Global Functions</title>
<para>This section lists all global functions.</para>


<sect4 id="dev-scripting-api-includes">
<title>Reading &amp; Including Files</title>

<variablelist><varlistentry>
<term><synopsis>
String read(<parameter>String <replaceable>file</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Will search the given <replaceable>file</replaceable> relative to the <literal>katepart5/script/files</literal> directory and return its content as a string.
</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
void require(<parameter>String <replaceable>file</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Will search the given <replaceable>file</replaceable> relative to the <literal>katepart5/script/libraries</literal> directory and evaluate it.
<literal>require</literal> is internally guarded against multiple inclusions of the same <replaceable>file</replaceable>.
</para>
<para>
  Since: &kde; 4.10
</para>
</listitem>
</varlistentry></variablelist>

</sect4>

<sect4 id="dev-scripting-api-debug">
<title>Debugging</title>

<variablelist><varlistentry>
<term><synopsis>
void debug(<parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Prints <replaceable>text</replaceable> to <literal>stdout</literal> in the
console launching the application.
</para></listitem>
</varlistentry></variablelist>

</sect4>

<sect4 id="dev-scripting-api-i18n">
<title>Translation</title>

<para>In order to support full localization, there are several functions to translate
strings in scripts, namely <literal>i18n</literal>, <literal>i18nc</literal>,
<literal>i18np</literal> and <literal>i18ncp</literal>. These functions behave
exactly like <ulink url="https://techbase.kde.org/Development/Tutorials/Localization/i18n">
&kde;'s translation functions</ulink>.
</para>

<para>The translation functions translate the wrapped strings through &kde;'s
translation system to the language used in the application. Strings in scripts
being developed in the official &kappname; sources are automatically extracted and
translatable. In other words, as a &kappname; developer you do not have to bother with
message extraction and translation. It should be noted though, that the translation
only works inside the &kde; infrastructure, &ie;, new strings in 3rd-party
scripts developed outside of &kde; are not translated.
Therefore, please consider contributing your scripts to &kate; such that
proper translation is possible.
</para>

<variablelist><varlistentry>
<term><synopsis>
void i18n(<parameter>String <replaceable>text</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates <replaceable>text</replaceable> into the language used by the application.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, &etc;</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void i18nc(<parameter>String <replaceable>context</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates <replaceable>text</replaceable> into the language used by the
application. Additionally, the string <replaceable>context</replaceable> is
visible to translators so they can provide a better translation.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, &etc;</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void i18np(<parameter>String <replaceable>singular</replaceable></parameter>, <parameter>String <replaceable>plural</replaceable></parameter>, <parameter>int <replaceable>number</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates either <replaceable>singular</replaceable> or
<replaceable>plural</replaceable> into the language used by the application,
depending on the given <replaceable>number</replaceable>.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, &etc;</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void i18ncp(<parameter>String <replaceable>context</replaceable></parameter>, <parameter>String <replaceable>singular</replaceable></parameter>, <parameter>String <replaceable>plural</replaceable></parameter>, <parameter>int <replaceable>number</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates either <replaceable>singular</replaceable> or
<replaceable>plural</replaceable> into the language used by the application,
depending on the given <replaceable>number</replaceable>. Additionally, the
string <replaceable>context</replaceable> is visible to translators so they
can provide a better translation. The arguments <replaceable>arg1</replaceable>,
..., are optional and used to replace the placeholders <literal>%1</literal>,
<literal>%2</literal>, &etc;</para></listitem>
</varlistentry></variablelist>

</sect4>
</sect3>

<sect3 id="dev-scripting-api-view">
<title>The View API</title>
<para>Whenever a script is being executed, there is a global variable
<quote><literal>view</literal></quote> representing the current active editor
view. The following is a list of all available View functions.

<variablelist>

<varlistentry>
<term><synopsis>
<function>void view.copy()</function>
</synopsis></term>
<listitem>
<para>Copy the selection if there is one, otherwise the current line if the option <userinput>[ ] Copy/Cut the current line if no selection</userinput> is set.</para>
<para>Since: &kde-frameworks; 5.79</para>
</listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
<function>void view.cut()</function>
</synopsis></term>
<listitem>
<para>Cut the selection if there is one, otherwise the current line if the option <userinput>[ ] Copy/Cut the current line if no selection</userinput> is set.</para>
<para>Since: &kde-frameworks; 5.79</para>
</listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
<function>void view.paste()</function>
</synopsis></term>
<listitem>
<para>Paste the clipboard content.</para>
<para>Since: &kde-frameworks; 5.79</para>
</listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
<function>Cursor view.cursorPosition()</function>
</synopsis></term>
<listitem><para>Returns the current cursor position in the view.</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.setCursorPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
void view.setCursorPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the current cursor position to either (line, column) or to the given cursor.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor view.virtualCursorPosition();
</synopsis></term>
<listitem><para>
Returns the virtual cursor position with each tab counting the corresponding amount of spaces depending on the current tab width.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.setVirtualCursorPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
void view.setVirtualCursorPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the current virtual cursor position to (line, column) or to the given cursor.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String view.selectedText();
</synopsis></term>
<listitem><para>
Returns the selected text. If no text is selected, the returned string is empty.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool view.hasSelection();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the view has selected text, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range view.selection();
</synopsis></term>
<listitem><para>
Returns the selected text range. The returned range is invalid if there is no
selected text.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.setSelection(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the selected text to the given range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.removeSelectedText();
</synopsis></term>
<listitem><para>
Remove the selected text. If the view does not have any selected text, this
does nothing.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.selectAll();
</synopsis></term>
<listitem><para>
Selects the entire text in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.clearSelection();
</synopsis></term>
<listitem><para>
Clears the text selection without removing the text.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.setBlockSelection(bool on);
</synopsis></term>
<listitem><para>
Set block selection mode on or off.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
bool view.blockSelection();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if block selection mode is on, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.align(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Properly re-indent lines within <replaceable>range</replaceable> according to current indentation settings.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void view.alignOn(<parameter>Range <replaceable>range</replaceable></parameter>, <parameter>String <replaceable>pattern</replaceable> = &quot;&quot;</parameter>);
</synopsis></term>
<listitem><para>
Aligns lines in <replaceable>range</replaceable> on the column given by the regular expression <replaceable>pattern</replaceable>.
With an empty <replaceable>pattern</replaceable> it will align on the first non-blank character by default.
If the pattern has a capture it will indent on the captured match.
</para>
<para><emphasis>Examples:</emphasis></para>
<para><literal>view.alignOn(document.documentRange(), '-');</literal> will insert spaces before the first <literal>-</literal> of each lines to align them all on the same column.</para>
<para><literal>view.alignOn(document.documentRange(), ':\\s+(.)');</literal> will insert spaces before the first non-blank character that occurs after a colon to align them all on the same column.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
object view.executeCommand(<parameter>String <replaceable>command</replaceable></parameter>,
                           <parameter>String <replaceable>args</replaceable></parameter>,
                           <parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Executes the <link linkend="advanced-editing-tools-commandline">command line command</link> <replaceable>command</replaceable>
with the optional arguments <replaceable>args</replaceable> and the optional <replaceable>range</replaceable>.
The returned <replaceable>object</replaceable> has a boolean property <replaceable>object.ok</replaceable>
that indicates whether execution of the <replaceable>command</replaceable> was successful.
In case of an error, the string <replaceable>object.status</replaceable> contains an error message.
</para>
<para>Since: &kde-frameworks; 5.50</para>
</listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
Range view.searchText(<parameter>Range <replaceable>range</replaceable></parameter>,
                      <parameter>String <replaceable>pattern</replaceable></parameter>,
                      <parameter>bool <replaceable>backwards</replaceable> = false</parameter>);
</synopsis></term>
<listitem><para>
Search for the first occurrence of <replaceable>pattern</replaceable> in <replaceable>range</replaceable> and returns the matched range.
Search is performed backwards if the optional boolean parameter <replaceable>backwards</replaceable> is set to <literal>true</literal>.
</para>
<para>
The returned range is invalid (see Range.isValid()) if <replaceable>pattern</replaceable> is not found in <replaceable>range</replaceable>.
</para>
<para>Since: &kde-frameworks; 5.97</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</sect3>

<sect3 id="dev-scripting-api-document">
<title>The Document API</title>
<para>
Whenever a script is being executed, there is a global variable
<quote><literal>document</literal></quote> representing the current active
document. The following is a list of all available Document functions.

<variablelist>

<varlistentry>
<term><synopsis>
String document.fileName();
</synopsis></term>
<listitem><para>
Returns the document's filename or an empty string for unsaved text buffers.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.url();
</synopsis></term>
<listitem><para>
Returns the document's full &URL; or an empty string for unsaved text buffers.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.mimeType();
</synopsis></term>
<listitem><para>
Returns the document's &MIME; type or the &MIME; type <literal>application/octet-stream</literal>
if no appropriate &MIME; type could be found.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.encoding();
</synopsis></term>
<listitem><para>
Returns the currently used encoding to save the file.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
String document.highlightingMode();
</synopsis></term>
<listitem><para>
Returns the global highlighting mode used for the whole document.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
String document.highlightingModeAt(<parameter>Cursor <replaceable>pos</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns the highlighting mode used at the given position in the document.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
Array document.embeddedHighlightingModes();
</synopsis></term>
<listitem><para>
Returns an array of highlighting modes embedded in this document.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
bool document.isModified();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the document has unsaved changes (modified), otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.text();
</synopsis></term>
<listitem><para>
Returns the entire content of the document in a single text string. Newlines
are marked with the newline character <quote><literal>\n</literal></quote>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.text(<parameter>int <replaceable>fromLine</replaceable></parameter>, <parameter>int <replaceable>fromColumn</replaceable></parameter>, <parameter>int <replaceable>toLine</replaceable></parameter>, <parameter>int <replaceable>toColumn</replaceable></parameter>);
String document.text(<parameter>Cursor <replaceable>from</replaceable></parameter>, <parameter>Cursor <replaceable>to</replaceable></parameter>);
String document.text(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the text in the given range. It is recommended to use the cursor
    and range based version for better readability of the source code.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.line(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the given text line as string. The string is empty if the requested
    line is out of range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.wordAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.wordAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the word at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term>
<synopsis>
Range document.wordRangeAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
Range document.wordRangeAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis>
</term>
<listitem><para>
Return the range of the word at the given cursor position. The returned range
is invalid (see Range.isValid()), if the text position is after the end of a
line. If there is no word at the given cursor, an empty range is returned.
</para>
<para>
  Since: &kde; 4.9
</para>
</listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.charAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.charAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the character at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.firstChar(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the first character in the given <replaceable>line</replaceable>
    that is not a whitespace. The first character is at column 0. If the line
    is empty or only contains whitespace characters, the returned string is
    empty.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.lastChar(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the last character in the given <replaceable>line</replaceable>
    that is not a whitespace. If the line is empty or only contains whitespace
    characters, the returned string is empty.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isSpace(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isSpace(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the character at the given cursor position is a whitespace,
    otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.matchesAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
bool document.matchesAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>text</replaceable> matches at the
    corresponding cursor position, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.startsWith(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>bool <replaceable>skipWhiteSpaces</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the line starts with <replaceable>text</replaceable>, otherwise <literal>false</literal>.
    The argument <replaceable>skipWhiteSpaces</replaceable> controls whether leading whitespaces are ignored.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.endsWith(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>bool <replaceable>skipWhiteSpaces</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the line ends with <replaceable>text</replaceable>, otherwise <literal>false</literal>.
    The argument <replaceable>skipWhiteSpaces</replaceable> controls whether trailing whitespaces are ignored.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.setText(<parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Sets the entire document text.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.clear();
</synopsis></term>
<listitem><para>
    Removes the entire text in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.truncate(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.truncate(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Truncate the given line at the given column or cursor position. Returns <literal>true</literal>
    on success, or <literal>false</literal> if the given line is not part of the document range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.insertText(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
bool document.insertText(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Inserts the <replaceable>text</replaceable> at the given cursor position.
    Returns <literal>true</literal> on success, or <literal>false</literal>, if the document is in read-only mode.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.removeText(<parameter>int <replaceable>fromLine</replaceable></parameter>, <parameter>int <replaceable>fromColumn</replaceable></parameter>, <parameter>int <replaceable>toLine</replaceable></parameter>, <parameter>int <replaceable>toColumn</replaceable></parameter>);
bool document.removeText(<parameter>Cursor <replaceable>from</replaceable></parameter>, <parameter>Cursor <replaceable>to</replaceable></parameter>);
bool document.removeText(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Removes the text in the given range. Returns <literal>true</literal> on success, or <literal>false</literal>, if
    the document is in read-only mode.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.insertLine(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Inserts text in the given line. Returns <literal>true</literal> on success, or <literal>false</literal>, if the
    document is in read-only mode or the line is not in the document range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.removeLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Removes the given text line. Returns <literal>true</literal> on success, or <literal>false</literal>, if the
    document is in read-only mode or the line is not in the document range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.wrapLine(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.wrapLine(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Wraps the line at the given cursor position. Returns <literal>true</literal> on success,
otherwise <literal>false</literal>, &eg; if line &lt; 0.
</para>
<para>
  Since: &kde; 4.9
</para>
</listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.joinLines(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>int <replaceable>endLine</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Joins the lines from <replaceable>startLine</replaceable> to <replaceable>endLine</replaceable>.
    Two succeeding text lines are always separated with a single space.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lines();
</synopsis></term>
<listitem><para>
    Returns the number of lines in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isLineModified(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if <replaceable>line</replaceable> currently contains unsaved data.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isLineSaved(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if <replaceable>line</replaceable> was changed, but the document was saved.
    Hence, the line currently does not contain any unsaved data.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isLineTouched(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if <replaceable>line</replaceable> currently contains unsaved data or was changed before.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.findTouchedLine(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>bool <replaceable>down</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Search for the next touched line starting at <replaceable>line</replaceable>.
    The search is performed either upwards or downwards depending on the search direction specified in <replaceable>down</replaceable>.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.length();
</synopsis></term>
<listitem><para>
    Returns the number of characters in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lineLength(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the <replaceable>line</replaceable>'s length.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.editBegin();
</synopsis></term>
<listitem><para>
    Starts an edit group for undo/redo grouping. Make sure to always call
    <function>editEnd()</function> as often as you call
    <function>editBegin()</function>. Calling <function>editBegin()</function>
    internally uses a reference counter, &ie;, this call can be nested.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.editEnd();
</synopsis></term>
<listitem><para>
    Ends an edit group. The last call of <function>editEnd()</function> (&ie;
    the one for the first call of <function>editBegin()</function>) finishes
    the edit step.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.firstColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the first non-whitespace column in the given <replaceable>line</replaceable>.
    If there are only whitespaces in the line, the return value is <literal>-1</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lastColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the last non-whitespace column in the given <replaceable>line</replaceable>.
    If there are only whitespaces in the line, the return value is <literal>-1</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.prevNonSpaceColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.prevNonSpaceColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the column with a non-whitespace character starting at the given
    cursor position and searching backwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.nextNonSpaceColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.nextNonSpaceColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the column with a non-whitespace character starting at the given
    cursor position and searching forwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.prevNonEmptyLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the next non-empty line containing non-whitespace characters
    searching backwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.nextNonEmptyLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the next non-empty line containing non-whitespace characters
    searching forwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isInWord(<parameter>String <replaceable>character</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>character</replaceable> with the
    given <replaceable>attribute</replaceable> can be part of a word, otherwise
    <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.canBreakAt(<parameter>String <replaceable>character</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>character</replaceable> with the given
    <replaceable>attribute</replaceable> is suited to wrap a line, otherwise
    <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.canComment(<parameter>int <replaceable>startAttribute</replaceable></parameter>, <parameter>int <replaceable>endAttribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if a range starting and ending with the given attributes is
    suited to be commented out, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.commentMarker(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for single line comments for a given <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.commentStart(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for the start of multi-line comments for a given
    <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.commentEnd(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for the end of multi-line comments for a given
    <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range document.documentRange();
</synopsis></term>
<listitem><para>
    Returns a range that encompasses the whole document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor documentEnd();
</synopsis></term>
<listitem><para>
    Returns a cursor positioned at the last column of the last line in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool isValidTextPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool isValidTextPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given cursor position is positioned at a valid text position.
    A text position is valid only if it locate at the start, in the middle, or the end of a valid line.
    Further, a text position is invalid if it is located in a Unicode surrogate.
</para><para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.attribute(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.attribute(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the attribute at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isAttribute(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
bool document.isAttribute(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute at the given cursor position equals <replaceable>attribute</replaceable>,
    otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.attributeName(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.attributeName(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the attribute name as human readable text. This is equal to the
    <literal>itemData</literal> name in the syntax highlighting files.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isAttributeName(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>name</replaceable></parameter>);
bool document.isAttributeName(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>name</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute name at a certain cursor position matches
    the given <replaceable>name</replaceable>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.variable(<parameter>String <replaceable>key</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the value of the requested document variable <replaceable>key</replaceable>.
    If the document variable does not exist, the return value is an empty string.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.setVariable(<parameter>String <replaceable>key</replaceable></parameter>, <parameter>String <replaceable>value</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Set the value of the requested document variable <replaceable>key</replaceable>.
</para>
<para>
    See also: <link linkend="config-variables">Kate document variables</link>
</para>
<para>
    Since: &kde; 4.8
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.firstVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the virtual column of the first non-whitespace character in the given
    line or <literal>-1</literal>, if the line is empty or contains only whitespace characters.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lastVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the virtual column of the last non-whitespace character in the given
    line or <literal>-1</literal>, if the line is empty or contains only whitespace characters.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.toVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.toVirtualColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
Cursor document.toVirtualCursor(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Converts the given <quote>real</quote> cursor position to a virtual cursor position,
    either returning an int or a Cursor object.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.fromVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>virtualColumn</replaceable></parameter>);
int document.fromVirtualColumn(<parameter>Cursor <replaceable>virtualCursor</replaceable></parameter>);
Cursor document.fromVirtualCursor(<parameter>Cursor <replaceable>virtualCursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Converts the given virtual cursor position to a <quote>real</quote> cursor position,
    either returning an int or a Cursor object.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor document.anchor(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>Char <replaceable>character</replaceable></parameter>);
Cursor document.anchor(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>Char <replaceable>character</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Searches backward for the given character starting from the given cursor.
    As an example, if '(' is passed as character, this function will return the
    position of the opening '('. This reference counting, &ie; other '(...)'
    are ignored.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor document.rfind(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable> = -1</parameter>);
Cursor document.rfind(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable> = -1</parameter>);
</synopsis></term>
<listitem><para>
    Find searching backwards the given text with the appropriate <replaceable>attribute</replaceable>.
    The argument <replaceable>attribute</replaceable> is ignored if it is set to
    <literal>-1</literal>. The returned cursor is invalid, if the text could not be found.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.defStyleNum(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.defStyleNum(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the default style used at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isCode(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isCode(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute at the given cursor position is not equal
    to all of the following styles: <literal>dsComment</literal>,
    <literal>dsString</literal>, <literal>dsRegionMarker</literal>,
    <literal>dsChar</literal>, <literal>dsOthers</literal>.
</para></listitem>
</varlistentry>



<varlistentry>
<term><synopsis>
bool document.isComment(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isComment(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsComment</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isString(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isString(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsString</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isRegionMarker(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isRegionMarker(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsRegionMarker</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isChar(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isChar(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsChar</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isOthers(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isOthers(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsOthers</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void document.indent(<parameter>Range <replaceable>range</replaceable></parameter>, <parameter>int <replaceable>change</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Indents all lines in <replaceable>range</replaceable> by <replaceable>change</replaceable> tabs or <replaceable>change</replaceable> times <literal>tabSize</literal> spaces depending on the users preferences. The <replaceable>change</replaceable> parameter can be negative.
</para></listitem>
</varlistentry>

</variablelist>
</para>

</sect3>

<sect3 id="dev-scripting-api-editor">
<title>The Editor API</title>
<para>
In addition to the document and view API, there is a general editor API that
provides functions for general editor scripting functionality.

<variablelist>

<varlistentry>
<term><synopsis>
String editor.clipboardText();
</synopsis></term>
<listitem><para>
Returns the text that currently is in the global clipboard.
</para>
<para>Since: &kde-frameworks; 5.50</para>
</listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
String editor.clipboardHistory();
</synopsis></term>
<listitem><para>
The editor holds a clipboard history that contains up to 10 clipboard entries.
This function returns all entries that currently are in the clipboard history.
</para>
<para>Since: &kde-frameworks; 5.50</para>
</listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void editor.setClipboardText(<parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the contents of the clipboard to <replaceable>text</replaceable>.
The <replaceable>text</replaceable> will be added to the clipboard history.
</para>
<para>Since: &kde-frameworks; 5.50</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</sect3>
</sect2>

</sect1>

</chapter>
