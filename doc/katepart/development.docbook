<!-- auto-generate scripting documentation (kwrite-devel@kde.org Re: [kate] doc/kate: document most of the new scripts in 4.10) -->
<chapter id="dev">
<chapterinfo>
<authorgroup>
<author>&TC.Hollingsworth; &TC.Hollingsworth.mail;</author>
<!-- TRANS:ROLES_OF_TRANSLATORS -->
</authorgroup>
</chapterinfo>
<title>Extending &katepart;</title>

<sect1 id="dev-intro">
<title>Introduction</title>

<para>Like any advanced text editor component, &katepart; offers a variety of
ways to extend its functionality.  You can <link linkend="dev-scripting">write 
simple scripts to add functionality with JavaScript</link>. 
Finally, once you have extended &katepart;, you are
welcome to <ulink url="http://kate-editor.org/join-us/">join us</ulink> 
and share your enhancements with the world!</para>

</sect1>

<sect1 id="highlight">
<title>Working with Syntax Highlighting</title>

<sect2 id="highlight-overview">

<title>Overview</title>

<para>Syntax Highlighting is what makes the editor automatically
display text in different styles/colors, depending on the function of
the string in relation to the purpose of the file.  In program source
code for example, control statements may be rendered bold, while data
types and comments get different colors from the rest of the
text. This greatly enhances the readability of the text, and thus
helps the author to be more efficient and productive.</para>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="highlighted.png"/></imageobject>
<textobject><phrase>A Perl function, rendered with syntax
highlighting.</phrase></textobject>
<caption><para>A Perl function, rendered with syntax highlighting.</para>
</caption>
</mediaobject>

<mediaobject>
<imageobject><imagedata format="PNG" fileref="unhighlighted.png"/></imageobject>
<textobject><phrase>The same Perl function, without
highlighting.</phrase></textobject>
<caption><para>The same Perl function, without highlighting.</para></caption>
</mediaobject>

<para>Of the two examples, which is easiest to read?</para>

<para>&kappname; comes with a flexible, configurable and capable system
for doing syntax highlighting, and the standard distribution provides
definitions for a wide range of programming, scripting and markup
languages and other text file formats. In addition you can
provide your own definitions in simple &XML; files.</para>

<para>&kappname; will automatically detect the right syntax rules when you
open a file, based on the &MIME; Type of the file, determined by its
extension, or, if it has none, the contents. Should you experience a
bad choice, you can manually set the syntax to use from the
<menuchoice><guimenu>Tools</guimenu><guisubmenu>Highlighting
</guisubmenu></menuchoice> menu.</para>

<para>The styles and colors used by each syntax highlight definition
can be configured using the <link
linkend="prefcolors-highlighting-text-styles">Highlighting Text Styles</link> tab of the
<link linkend="config-dialog">Config Dialog</link>, while the &MIME; Types and
file extensions it should be used for are handled by the <link
linkend="pref-open-save-modes-filetypes">Modes &amp; Filetypes</link>
tab.</para>

<note>
<para>Syntax highlighting is there to enhance the readability of
correct text, but you cannot trust it to validate your text. Marking
text for syntax is difficult depending on the format you are using,
and in some cases the authors of the syntax rules will be proud if 98%
of text gets correctly rendered, though most often you need a rare
style to see the incorrect 2%.</para>
</note>

<tip>
<para>You can download updated or additional syntax highlight
definitions from the &kappname; website by clicking the
<guibutton>Download Highlighting Files...</guibutton> button in the <link
linkend="pref-open-save-modes-filetypes">Modes &amp; Filetypes</link> tab of the <link
linkend="config-dialog">Config Dialog</link>.</para>
</tip>

</sect2>

<sect2 id="katehighlight-system">

<title>The &kappname; Syntax Highlight System</title>

<para>This section will discuss the &kappname; syntax highlighting
mechanism in more detail. It is for you if you want to know about
it, or if you want to change or create syntax definitions.</para>

<sect3 id="katehighlight-howitworks">

<title>How it Works</title>

<para>Whenever you open a file, one of the first things the &kappname;
editor does is detect which syntax definition to use for the
file. While reading the text of the file, and while you type away in
it, the syntax highlighting system will analyze the text using the
rules defined by the syntax definition and mark in it where different
contexts and styles begin and end.</para>

<para>When you type in the document, the new text is analyzed and marked on the
fly, so that if you delete a character that is marked as the beginning or end
of a context, the style of surrounding text changes accordingly.</para>

<para>The syntax definitions used by the &kappname; Syntax Highlighting System are
&XML; files, containing
<itemizedlist>
<listitem><para>Rules for detecting the role of text, organized into context blocks</para></listitem>
<listitem><para>Keyword lists</para></listitem>
<listitem><para>Style Item definitions</para></listitem>
</itemizedlist>
</para>

<para>When analyzing the text, the detection rules are evaluated in
the order in which they are defined, and if the beginning of the
current string matches a rule, the related context is used. The start
point in the text is moved to the final point at which that rule
matched and a new loop of the rules begins, starting in the context
set by the matched rule.</para>

</sect3>

<sect3 id="highlight-system-rules">
<title>Rules</title>

<para>The detection rules are the heart of the highlighting detection
system. A rule is a string, character or <link
linkend="regular-expressions">regular expression</link> against which
to match the text being analyzed. It contains information about which
style to use for the matching part of the text. It may switch the
working context of the system either to an explicitly mentioned
context or to the previous context used by the text.</para>

<para>Rules are organized in context groups. A context group is used
for main text concepts within the format, for example quoted text
strings or comment blocks in program source code. This ensures that
the highlighting system does not need to loop through all rules when
it is not necessary, and that some character sequences in the text can
be treated differently depending on the current context.
</para>

<para>Contexts may be generated dynamically to allow the usage of instance
specific data in rules.</para>

</sect3>

<sect3 id="highlight-context-styles-keywords">
<title>Context Styles and Keywords</title>

<para>In some programming languages, integer numbers are treated
differently from floating point ones by the compiler (the program that
converts the source code to a binary executable), and there may be
characters having a special meaning within a quoted string. In such
cases, it makes sense to render them differently from the surroundings
so that they are easy to identify while reading the text. So even if
they do not represent special contexts, they may be seen as such by
the syntax highlighting system, so that they can be marked for
different rendering.</para>

<para>A syntax definition may contain as many styles as required to
cover the concepts of the format it is used for.</para>

<para>In many formats, there are lists of words that represent a
specific concept. For example, in programming languages, control
statements are one concept, data type names another, and built in
functions of the language a third. The &kappname; Syntax Highlighting
System can use such lists to detect and mark words in the text to
emphasize concepts of the text formats.</para>

</sect3>

<sect3 id="kate-highlight-system-default-styles">
<title>Default Styles</title>

<para>If you open a C++ source file, a &Java; source file and an
<acronym>HTML</acronym> document in &kappname;, you will see that even
though the formats are different, and thus different words are chosen
for special treatment, the colors used are the same. This is because
&kappname; has a predefined list of Default Styles which are employed by
the individual syntax definitions.</para>

<para>This makes it easy to recognize similar concepts in different
text formats. For example, comments are present in almost any
programming, scripting or markup language, and when they are rendered
using the same style in all languages, you do not have to stop and
think to identify them within the text.</para>

<tip>
<para>All styles in a syntax definition use one of the default
styles. A few syntax definitions use more styles than there are
defaults, so if you use a format often, it may be worth launching the
configuration dialog to see if some concepts use the same
style. For example, there is only one default style for strings, but as
the Perl programming language operates with two types of strings, you
can enhance the highlighting by configuring those to be slightly
different. All <link linkend="kate-highlight-default-styles">available default styles</link>
will be explained later.</para>
</tip>

</sect3>

</sect2>

<sect2 id="katehighlight-xml-format">
<title>The Highlight Definition &XML; Format</title>

<sect3>
<title>Overview</title>

<para>&kappname; uses the Syntax-Highlighting framework from &kde-frameworks;.
The default highlighting xml files shipped with &kappname; are compiled
into the Syntax-Highlighting library by default.
</para>

<para>This section is an overview of the Highlight Definition &XML;
format. Based on a small example it will describe the main components
and their meaning and usage. The next section will go into detail with
the highlight detection rules.</para>

<para>The formal definition, also known as the <acronym>XSD</acronym> you
find in <ulink url="https://commits.kde.org/syntax-highlighting?path=data/schema">Syntax
Highlighting repository</ulink> in the file <filename>language.xsd</filename>
</para>

<para>Custom <filename class="extension">.xml</filename> highlight definition files are
located in <filename class="directory">org.kde.syntax-highlighting/syntax/</filename> in
your user folder found with <userinput><command>qtpaths</command><option>--paths
GenericDataLocation</option></userinput> which usually is
<filename class="directory"><envar>$HOME</envar>/.local/share</filename>
</para>

<para>On &Windows; these files are located <filename>%USERPROFILE%/AppData/Local/org.kde.syntax-highlighting/syntax</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.</para>

<variablelist>
<title>Main sections of &kappname; Highlight Definition files</title>

<varlistentry>
<term>A highlighting file contains a header that sets the XML version:</term>
<listitem>
<programlisting>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</programlisting>
</listitem>
</varlistentry>

<varlistentry>
<term>The root of the definition file is the element <userinput>language</userinput>.
Available attributes are:</term>

<listitem>
<para>Required attributes:</para>
<para><userinput>name</userinput> sets the name of the language. It appears in the menus and dialogs afterwards.</para>
<para><userinput>section</userinput> specifies the category.</para>
<para><userinput>extensions</userinput> defines file extensions, such as &quot;*.cpp;*.h&quot;</para>
<para><userinput>version</userinput> specifies the current revision of the definition file in terms of an integer number. Whenever you change a highlighting definition file, make sure to increase this number.</para>
<para><userinput>kateversion</userinput> specifies the latest supported &kappname; version.</para>

<para>Optional attributes:</para>
<para><userinput>mimetype</userinput> associates files &MIME; type.</para>
<para><userinput>casesensitive</userinput> defines, whether the keywords are case sensitive or not.</para>
<para><userinput>priority</userinput> is necessary if another highlight definition file uses the same extensions. The higher priority will win.</para>
<para><userinput>author</userinput> contains the name of the author and his email-address.</para>
<para><userinput>license</userinput> contains the license, usually the MIT license for new syntax-highlighting files.</para>
<para><userinput>style</userinput> contains the provided language and is used by the indenters for the attribute <literal>required-syntax-style</literal>.</para>
<para><userinput>hidden</userinput> defines whether the name should appear in &kappname;'s menus.</para>
<para>So the next line may look like this:</para>
<programlisting>
&lt;language name=&quot;C++&quot; version=&quot;1&quot; kateversion=&quot;2.4&quot; section=&quot;Sources&quot; extensions=&quot;*.cpp;*.h&quot; /&gt;
</programlisting>
</listitem>
</varlistentry>


<varlistentry>
<term>Next comes the <userinput>highlighting</userinput> element, which
contains the optional element <userinput>list</userinput> and the required
elements <userinput>contexts</userinput> and <userinput>itemDatas</userinput>.</term>
<listitem>
<para><userinput>list</userinput> elements contain a list of keywords. In
this case the keywords are <emphasis>class</emphasis> and <emphasis>const</emphasis>.
You can add as many lists as you need.</para>
<para>The <userinput>contexts</userinput> element contains all contexts.
The first context is by default the start of the highlighting. There are
two rules in the context <emphasis>Normal Text</emphasis>, which match
the list of keywords with the name <emphasis>somename</emphasis> and a
rule that detects a quote and switches the context to <emphasis>string</emphasis>.
To learn more about rules read the next chapter.</para>
<para>The third part is the <userinput>itemDatas</userinput> element. It
contains all color and font styles needed by the contexts and rules.
In this example, the <userinput>itemData</userinput> <emphasis>Normal Text</emphasis>,
<emphasis>String</emphasis> and <emphasis>Keyword</emphasis> are used.
</para>
<programlisting>
  &lt;highlighting&gt;
    &lt;list name=&quot;somename&quot;&gt;
      &lt;item&gt; class &lt;/item&gt;
      &lt;item&gt; const &lt;/item&gt;
    &lt;/list&gt;
    &lt;contexts&gt;
      &lt;context attribute=&quot;Normal Text&quot; lineEndContext=&quot;#pop&quot; name=&quot;Normal Text&quot; &gt;
        &lt;keyword attribute=&quot;Keyword&quot; context=&quot;#stay&quot; String=&quot;somename&quot; /&gt;
        &lt;DetectChar attribute=&quot;String&quot; context=&quot;string&quot; char=&quot;&amp;quot;&quot; /&gt;
      &lt;/context&gt;
      &lt;context attribute=&quot;String&quot; lineEndContext=&quot;#stay&quot; name=&quot;string&quot; &gt;
        &lt;DetectChar attribute=&quot;String&quot; context=&quot;#pop&quot; char=&quot;&amp;quot;&quot; /&gt;
      &lt;/context&gt;
    &lt;/contexts&gt;
    &lt;itemDatas&gt;
      &lt;itemData name=&quot;Normal Text&quot; defStyleNum=&quot;dsNormal&quot; /&gt;
      &lt;itemData name=&quot;Keyword&quot; defStyleNum=&quot;dsKeyword&quot; /&gt;
      &lt;itemData name=&quot;String&quot; defStyleNum=&quot;dsString&quot; /&gt;
    &lt;/itemDatas&gt;
  &lt;/highlighting&gt;
</programlisting>
</listitem>
</varlistentry>

<varlistentry>
<term>The last part of a highlight definition is the optional
<userinput>general</userinput> section. It may contain information
about keywords, code folding, comments and indentation.</term>

<listitem>
<para>The <userinput>comment</userinput> section defines with what
string a single line comment is introduced. You also can define a
multiline comment using <emphasis>multiLine</emphasis> with the
additional attribute <emphasis>end</emphasis>. This is used if the
user presses the corresponding shortcut for <emphasis>comment/uncomment</emphasis>.</para>
<para>The <userinput>keywords</userinput> section defines whether
keyword lists are case sensitive or not. Other attributes will be
explained later.</para>
<programlisting>
  &lt;general&gt;
    &lt;comments&gt;
      &lt;comment name="singleLine" start="#"/&gt;
    &lt;/comments&gt;
    &lt;keywords casesensitive="1"/&gt;
  &lt;/general&gt;
&lt;/language&gt;
</programlisting>
</listitem>
</varlistentry>

</variablelist>


</sect3>

<sect3 id="kate-highlight-sections">
<title>The Sections in Detail</title>
<para>This part will describe all available attributes for contexts,
itemDatas, keywords, comments, code folding and indentation.</para>

<variablelist>
<varlistentry>
<term>The element <userinput>context</userinput> belongs in the group
<userinput>contexts</userinput>. A context itself defines context specific
rules such as what should happen if the highlight system reaches the end of a
line. Available attributes are:</term>


<listitem>
<para><userinput>name</userinput> states the context name. Rules will use this name
to specify the context to switch to if the rule matches.</para>
<para><userinput>lineEndContext</userinput> defines the context the highlight
system switches to if it reaches the end of a line. This may either be a name
of another context, <userinput>#stay</userinput> to not switch the context
(&eg;. do nothing) or <userinput>#pop</userinput> which will cause it to leave this
context. It is possible to use for example <userinput>#pop#pop#pop</userinput>
to pop three times, or even <userinput>#pop#pop!OtherContext</userinput> to pop
two times and switch to the context named <userinput>OtherContext</userinput>.</para>
<para><userinput>lineEmptyContext</userinput> defines the context if an empty
line is encountered. Default: #stay.</para>
<para><userinput>fallthrough</userinput> defines if the highlight system switches
to the context specified in fallthroughContext if no rule matches.
Default: <emphasis>false</emphasis>.</para>
<para><userinput>fallthroughContext</userinput> specifies the next context
if no rule matches.</para>
<para><userinput>dynamic</userinput> if <emphasis>true</emphasis>, the context
remembers strings/placeholders saved by dynamic rules. This is needed for HERE
documents for example. Default: <emphasis>false</emphasis>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>itemData</userinput> is in the group
<userinput>itemDatas</userinput>. It defines the font style and colors.
So it is possible to define your own styles and colors. However, we
recommend you stick to the default styles if possible so that the user
will always see the same colors used in different languages. Though,
sometimes there is no other way and it is necessary to change color
and font attributes. The attributes name and defStyleNum are required,
the others are optional. Available attributes are:</term>

<listitem>
<para><userinput>name</userinput> sets the name of the itemData.
Contexts and rules will use this name in their attribute
<emphasis>attribute</emphasis> to reference an itemData.</para>
<para><userinput>defStyleNum</userinput> defines which default style to use.
Available default styles are explained in detail later.</para>
<para><userinput>color</userinput> defines a color. Valid formats are
'#rrggbb' or '#rgb'.</para>
<para><userinput>selColor</userinput> defines the selection color.</para>
<para><userinput>italic</userinput> if <emphasis>true</emphasis>, the text will be italic.</para>
<para><userinput>bold</userinput> if <emphasis>true</emphasis>, the text will be bold.</para>
<para><userinput>underline</userinput> if <emphasis>true</emphasis>, the text will be underlined.</para>
<para><userinput>strikeout</userinput> if <emphasis>true</emphasis>, the text will be struck out.</para>
<para><userinput>spellChecking</userinput> if <emphasis>true</emphasis>, the text will be spellchecked.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>keywords</userinput> in the group
<userinput>general</userinput> defines keyword properties. Available attributes are:</term>

<listitem>
<para><userinput>casesensitive</userinput> may be <emphasis>true</emphasis>
or <emphasis>false</emphasis>. If <emphasis>true</emphasis>, all keywords
are matched case sensitively.</para>
<para><userinput>weakDeliminator</userinput> is a list of characters that
do not act as word delimiters. For example, the dot <userinput>'.'</userinput>
is a word delimiter. Assume a keyword in a <userinput>list</userinput> contains
a dot, it will only match if you specify the dot as a weak delimiter.</para>
<para><userinput>additionalDeliminator</userinput> defines additional delimiters.</para>
<para><userinput>wordWrapDeliminator</userinput> defines characters after which a
line wrap may occur.</para>
<para>Default delimiters and word wrap delimiters are the characters
<userinput>.():!+,-&lt;=&gt;%&amp;*/;?[]^{|}~\</userinput>, space (<userinput>' '</userinput>)
and tabulator (<userinput>'\t'</userinput>).</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>comment</userinput> in the group
<userinput>comments</userinput> defines comment properties which are used
for <menuchoice><guimenu>Tools</guimenu><guimenuitem>Comment</guimenuitem></menuchoice> and
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Uncomment</guimenuitem></menuchoice>.
Available attributes are:</term>

<listitem>
<para><userinput>name</userinput> is either <emphasis>singleLine</emphasis>
or <emphasis>multiLine</emphasis>. If you choose <emphasis>multiLine</emphasis>
the attributes <emphasis>end</emphasis> and <emphasis>region</emphasis> are
required.</para>
<para><userinput>start</userinput> defines the string used to start a comment.
In C++ this would be &quot;/*&quot;.</para>
<para><userinput>end</userinput> defines the string used to close a comment.
In C++ this would be &quot;*/&quot;.</para>
<para><userinput>region</userinput> should be the name of the foldable
multiline comment. Assume you have <emphasis>beginRegion="Comment"</emphasis>
... <emphasis>endRegion="Comment"</emphasis> in your rules, you should use
<emphasis>region="Comment"</emphasis>. This way uncomment works even if you
do not select all the text of the multiline comment. The cursor only must be
in the multiline comment.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>folding</userinput> in the group
<userinput>general</userinput> defines code folding properties.
Available attributes are:</term>

<listitem>
<para><userinput>indentationsensitive</userinput> if <emphasis>true</emphasis>, the code folding markers
will be added indentation based, as in the scripting language Python. Usually you
do not need to set it, as it defaults to <emphasis>false</emphasis>.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>The element <userinput>indentation</userinput> in the group
<userinput>general</userinput> defines which indenter will be used. However, we strongly
recommend you omit this element, as the indenter usually will be set by either defining
a File Type or by adding a mode line to the text file. If you specify an indenter though,
you will force a specific indentation on the user, which he might not like at all.
Available attributes are:</term>

<listitem>
<para><userinput>mode</userinput> is the name of the indenter. Available indenters
right now are: <emphasis>normal, cstyle, haskell, lilypond, lisp, python, ruby</emphasis>
and <emphasis>xml</emphasis>.</para>
</listitem>
</varlistentry>


</variablelist>


</sect3>

<sect3 id="kate-highlight-default-styles">
<title>Available Default Styles</title>
<para>Default Styles were <link linkend="kate-highlight-system-default-styles">already explained</link>,
as a short summary: Default styles are predefined font and color styles.</para>
<variablelist>
<varlistentry>
<term>General default styles:</term>
<listitem>
<para><userinput>dsNormal</userinput>, when no special highlighting is required.</para>
<para><userinput>dsKeyword</userinput>, built-in language keywords.</para>
<para><userinput>dsFunction</userinput>, function calls and definitions.</para>
<para><userinput>dsVariable</userinput>, if applicable: variable names (e.g. $someVar in PHP/Perl).</para>
<para><userinput>dsControlFlow</userinput>, control flow keywords like if, else, switch, break, return, yield, ...</para>
<para><userinput>dsOperator</userinput>, operators like + - * / :: &lt; &gt;</para>
<para><userinput>dsBuiltIn</userinput>, built-in functions, classes, and objects.</para>
<para><userinput>dsExtension</userinput>, common extensions, such as Qt classes and functions/macros in C++ and Python.</para>
<para><userinput>dsPreprocessor</userinput>, preprocessor statements or macro definitions.</para>
<para><userinput>dsAttribute</userinput>, annotations such as @override and __declspec(...).</para>
</listitem>
</varlistentry>

<varlistentry>
<term>String-related default styles:</term>
<listitem>
<para><userinput>dsChar</userinput>, single characters, such as 'x'.</para>
<para><userinput>dsSpecialChar</userinput>, chars with special meaning in strings such as escapes, substitutions, or regex operators.</para>
<para><userinput>dsString</userinput>, strings like "hello world".</para>
<para><userinput>dsVerbatimString</userinput>, verbatim or raw strings like 'raw \backlash' in Perl, CoffeeScript, and shells, as well as r'\raw' in Python.</para>
<para><userinput>dsSpecialString</userinput>, SQL, regexes, HERE docs, LaTeX math mode, ...</para>
<para><userinput>dsImport</userinput>, import, include, require of modules.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Number-related default styles:</term>
<listitem>
<para><userinput>dsDataType</userinput>, built-in data types like int, void, u64.</para>
<para><userinput>dsDecVal</userinput>, decimal values.</para>
<para><userinput>dsBaseN</userinput>, values with a base other than 10.</para>
<para><userinput>dsFloat</userinput>, floating point values.</para>
<para><userinput>dsConstant</userinput>, built-in and user defined constants like PI.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Comment and documentation-related default styles:</term>
<listitem>
<para><userinput>dsComment</userinput>, comments.</para>
<para><userinput>dsDocumentation</userinput>, /** Documentation comments */ or """docstrings""".</para>
<para><userinput>dsAnnotation</userinput>, documentation commands like @param, @brief.</para>
<para><userinput>dsCommentVar</userinput>, the variable names used in above commands, like "foobar" in @param foobar.</para>
<para><userinput>dsRegionMarker</userinput>, region markers like //BEGIN, //END in comments.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Other default styles:</term>
<listitem>
<para><userinput>dsInformation</userinput>, notes and tips like @note in doxygen.</para>
<para><userinput>dsWarning</userinput>, warnings like @warning in doxygen.</para>
<para><userinput>dsAlert</userinput>, special words like TODO, FIXME, XXXX.</para>
<para><userinput>dsError</userinput>, error highlighting and wrong syntax.</para>
<para><userinput>dsOthers</userinput>, when nothing else fits.</para>
</listitem>
</varlistentry>
</variablelist>

</sect3>

</sect2>

<sect2 id="kate-highlight-rules-detailled">
<title>Highlight Detection Rules</title>

<para>This section describes the syntax detection rules.</para>

<para>Each rule can match zero or more characters at the beginning of
the string they are tested against. If the rule matches, the matching
characters are assigned the style or <emphasis>attribute</emphasis>
defined by the rule, and a rule may ask that the current context is
switched.</para>

<para>A rule looks like this:</para>

<programlisting>&lt;RuleName attribute=&quot;(identifier)&quot; context=&quot;(identifier)&quot; [rule specific attributes] /&gt;</programlisting>

<para>The <emphasis>attribute</emphasis> identifies the style to use
for matched characters by name, and the <emphasis>context</emphasis>
identifies the context to use from here.</para>

<para>The <emphasis>context</emphasis> can be identified by:</para>

<itemizedlist>
<listitem>
<para>An <emphasis>identifier</emphasis>, which is the name of the other
context.</para>
</listitem>
<listitem>
<para>An <emphasis>order</emphasis> telling the engine to stay in the
current context (<userinput>#stay</userinput>), or to pop back to a
previous context used in the string (<userinput>#pop</userinput>).</para>
<para>To go back more steps, the #pop keyword can be repeated:
<userinput>#pop#pop#pop</userinput></para>
</listitem>
<listitem>
<para>An <emphasis>order</emphasis> followed by an exclamation mark
(<emphasis>!</emphasis>) and an <emphasis>identifier</emphasis>, which
will make the engine first follow the order and then switch to the
other context, e.g. <userinput>#pop#pop!OtherContext</userinput>.</para>
</listitem>
</itemizedlist>

<para>Some rules can have <emphasis>child rules</emphasis> which are
then evaluated only if the parent rule matched. The entire matched
string will be given the attribute defined by the parent rule. A rule
with child rules looks like this:</para>

<programlisting>
&lt;RuleName (attributes)&gt;
  &lt;ChildRuleName (attributes) /&gt;
  ...
&lt;/RuleName&gt;
</programlisting>


<para>Rule specific attributes varies and are described in the
following sections.</para>


<itemizedlist>
<title>Common attributes</title>
<para>All rules have the following attributes in common and are
available whenever <userinput>(common attributes)</userinput> appears.
<emphasis>attribute</emphasis> and <emphasis>context</emphasis>
are required attributes, all others are optional.
</para>

<listitem>
<para><emphasis>attribute</emphasis>: An attribute maps to a defined <emphasis>itemData</emphasis>.</para>
</listitem>
<listitem>
<para><emphasis>context</emphasis>: Specify the context to which the highlighting system switches if the rule matches.</para>
</listitem>
<listitem>
<para><emphasis>beginRegion</emphasis>: Start a code folding block. Default: unset.</para>
</listitem>
<listitem>
<para><emphasis>endRegion</emphasis>: Close a code folding block. Default: unset.</para>
</listitem>
<listitem>
<para><emphasis>lookAhead</emphasis>: If <emphasis>true</emphasis>, the
highlighting system will not process the matches length.
Default: <emphasis>false</emphasis>.</para>
</listitem>
<listitem>
<para><emphasis>firstNonSpace</emphasis>: Match only, if the string is
the first non-whitespace in the line. Default: <emphasis>false</emphasis>.</para>
</listitem>
<listitem>
<para><emphasis>column</emphasis>: Match only, if the column matches. Default: unset.</para>
</listitem>
</itemizedlist>

<itemizedlist>
<title>Dynamic rules</title>
<para>Some rules allow the optional attribute <userinput>dynamic</userinput>
of type boolean that defaults to <emphasis>false</emphasis>. If dynamic is
<emphasis>true</emphasis>, a rule can use placeholders representing the text
matched by a <emphasis>regular expression</emphasis> rule that switched to the
current context in its <userinput>string</userinput> or
<userinput>char</userinput> attributes. In a <userinput>string</userinput>,
the placeholder <replaceable>%N</replaceable> (where N is a number) will be
replaced with the corresponding capture <replaceable>N</replaceable>
from the calling regular expression. In a
<userinput>char</userinput> the placeholder must be a number
<replaceable>N</replaceable> and it will be replaced with the first character of
the corresponding capture <replaceable>N</replaceable> from the calling regular
expression. Whenever a rule allows this attribute it will contain a
<emphasis>(dynamic)</emphasis>.</para>

<listitem>
<para><emphasis>dynamic</emphasis>: may be <emphasis>(true|false)</emphasis>.</para>
</listitem>
</itemizedlist>

<sect3 id="highlighting-rules-in-detail">
<title>The Rules in Detail</title>

<variablelist>
<varlistentry>
<term>DetectChar</term>
<listitem>
<para>Detect a single specific character. Commonly used for example to
find the ends of quoted strings.</para>
<programlisting>&lt;DetectChar char=&quot;(character)&quot; (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>char</userinput> attribute defines the character
to match.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Detect2Chars</term>
<listitem>
<para>Detect two specific characters in a defined order.</para>
<programlisting>&lt;Detect2Chars char=&quot;(character)&quot; char1=&quot;(character)&quot; (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>char</userinput> attribute defines the first character to match,
<userinput>char1</userinput> the second.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>AnyChar</term>
<listitem>
<para>Detect one character of a set of specified characters.</para>
<programlisting>&lt;AnyChar String=&quot;(string)&quot; (common attributes) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the set of
characters.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>StringDetect</term>
<listitem>
<para>Detect an exact string.</para>
<programlisting>&lt;StringDetect String=&quot;(string)&quot; [insensitive=&quot;true|false&quot;] (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the string
to match. The <userinput>insensitive</userinput> attribute defaults to
<emphasis>false</emphasis> and is passed to the string comparison
function. If the value is <emphasis>true</emphasis> insensitive
comparing is used.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>WordDetect</term>
<listitem>
<para>Detect an exact string but additionally require word boundaries
such as a dot <userinput>'.'</userinput> or a whitespace on the beginning
and the end of the word. Think of <userinput>\b&lt;string&gt;\b</userinput>
in terms of a regular expression, but it is faster than the rule <userinput>RegExpr</userinput>.</para>
<programlisting>&lt;WordDetect String=&quot;(string)&quot; [insensitive=&quot;true|false&quot;] (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the string
to match. The <userinput>insensitive</userinput> attribute defaults to
<emphasis>false</emphasis> and is passed to the string comparison
function. If the value is <emphasis>true</emphasis> insensitive
comparing is used.</para>
<para>Since: Kate 3.5 (KDE 4.5)</para>
</listitem>
</varlistentry>

<varlistentry>
<term>RegExpr</term>
<listitem>
<para>Matches against a regular expression.</para>
<programlisting>&lt;RegExpr String=&quot;(string)&quot; [insensitive=&quot;true|false&quot;] [minimal=&quot;true|false&quot;] (common attributes) (dynamic) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute defines the regular
expression.</para>
<para><userinput>insensitive</userinput> defaults to
<emphasis>false</emphasis> and is passed to the regular expression
engine.</para>
<para><userinput>minimal</userinput> defaults to
<emphasis>false</emphasis> and is passed to the regular expression
engine.</para>
<para>Because the rules are always matched against the beginning of
the current string, a regular expression starting with a caret
(<literal>^</literal>) indicates that the rule should only be
matched against the start of a line.</para>
<para>See <link linkend="regular-expressions">Regular Expressions</link>
for more information on those.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>keyword</term>
<listitem>
<para>Detect a keyword from a specified list.</para>
<programlisting>&lt;keyword String=&quot;(list name)&quot; (common attributes) /&gt;</programlisting>
<para>The <userinput>String</userinput> attribute identifies the
keyword list by name. A list with that name must exist.</para>
<para>The highlighting system processes keyword rules in a very optimized way.
This makes it an absolute necessity that any keywords to be matched need to be
surrounded by defined delimiters, either implied (the default delimiters),
or explicitly specified within the <emphasis>additionalDeliminator</emphasis>
property of the <emphasis>keywords</emphasis> tag.</para>
<para>If a keyword to be matched shall contain a delimiter character, this
respective character must be added to the <emphasis>weakDeliminator</emphasis>
property of the <emphasis>keywords</emphasis> tag.  This character will then
loose its delimiter property in all <emphasis>keyword</emphasis> rules.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Int</term>
<listitem>
<para>Detect an integer number.</para>
<para><programlisting>&lt;Int (common attributes) (dynamic) /&gt;</programlisting></para>
<para>This rule has no specific attributes. Child rules are typically
used to detect combinations of <userinput>L</userinput> and
<userinput>U</userinput> after the number, indicating the integer type
in program code. Actually all rules are allowed as child rules, though,
the <acronym>DTD</acronym> only allows the child rule <userinput>StringDetect</userinput>.</para>
<para>The following example matches integer numbers follows by the character 'L'.
<programlisting>
&lt;Int attribute="Decimal" context="#stay" &gt;
  &lt;StringDetect attribute="Decimal" context="#stay" String="L" insensitive="true"/&gt;
&lt;/Int&gt;
</programlisting></para>

</listitem>
</varlistentry>

<varlistentry>
<term>Float</term>
<listitem>
<para>Detect a floating point number.</para>
<para><programlisting>&lt;Float (common attributes) /&gt;</programlisting></para>
<para>This rule has no specific attributes. <userinput>AnyChar</userinput> is
allowed as a child rule and typically used to detect combinations, see rule
<userinput>Int</userinput> for reference.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>HlCOct</term>
<listitem>
<para>Detect an octal point number representation.</para>
<para><programlisting>&lt;HlCOct (common attributes) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>HlCHex</term>
<listitem>
<para>Detect a hexadecimal number representation.</para>
<para><programlisting>&lt;HlCHex (common attributes) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>HlCStringChar</term>
<listitem>
<para>Detect an escaped character.</para>
<para><programlisting>&lt;HlCStringChar (common attributes) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>

<para>It matches literal representations of characters commonly used in
program code, for example <userinput>\n</userinput>
(newline) or <userinput>\t</userinput> (TAB).</para>

<para>The following characters will match if they follow a backslash
(<literal>\</literal>):
<userinput>abefnrtv&quot;'?\</userinput>. Additionally, escaped
hexadecimal numbers such as for example <userinput>\xff</userinput> and
escaped octal numbers, for example <userinput>\033</userinput> will
match.</para>

</listitem>
</varlistentry>

<varlistentry>
<term>HlCChar</term>
<listitem>
<para>Detect an C character.</para>
<para><programlisting>&lt;HlCChar (common attributes) /&gt;</programlisting></para>
<para>This rule has no specific attributes.</para>

<para>It matches C characters enclosed in a tick (Example: <userinput>'c'</userinput>).
The ticks may be a simple character or an escaped character.
See HlCStringChar for matched escaped character sequences.</para>

</listitem>
</varlistentry>

<varlistentry>
<term>RangeDetect</term>
<listitem>
<para>Detect a string with defined start and end characters.</para>
<programlisting>&lt;RangeDetect char=&quot;(character)&quot;  char1=&quot;(character)&quot; (common attributes) /&gt;</programlisting>
<para><userinput>char</userinput> defines the character starting the range,
<userinput>char1</userinput> the character ending the range.</para>
<para>Useful to detect for example small quoted strings and the like, but
note that since the highlighting engine works on one line at a time, this
will not find strings spanning over a line break.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>LineContinue</term>
<listitem>
<para>Matches a specified char at the end of a line.</para>
<programlisting>&lt;LineContinue (common attributes) [char="\"] /&gt;</programlisting>
<para><userinput>char</userinput> optional character to match, default is
backslash (<userinput>'\'</userinput>). New since KDE 4.13.</para>
<para>This rule is useful for switching context at end of line. This is needed for
 example in C/C++ to continue macros or strings.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>IncludeRules</term>
<listitem>
<para>Include rules from another context or language/file.</para>
<programlisting>&lt;IncludeRules context=&quot;contextlink&quot; [includeAttrib=&quot;true|false&quot;] /&gt;</programlisting>

<para>The <userinput>context</userinput> attribute defines which context to include.</para>
<para>If it is a simple string it includes all defined rules into the current context, example:
<programlisting>&lt;IncludeRules context=&quot;anotherContext&quot; /&gt;</programlisting></para>

<para>
If the string contains a <userinput>##</userinput> the highlight system
will look for a context from another language definition with the given name,
for example
<programlisting>&lt;IncludeRules context=&quot;String##C++&quot; /&gt;</programlisting>
would include the context <emphasis>String</emphasis> from the <emphasis>C++</emphasis>
highlighting definition.</para>
<para>If <userinput>includeAttrib</userinput> attribute is
<emphasis>true</emphasis>, change the destination attribute to the one of
the source. This is required to make, for example, commenting work, if text
matched by the included context is a different highlight from the host
context.
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>DetectSpaces</term>
<listitem>
<para>Detect whitespaces.</para>
<programlisting>&lt;DetectSpaces (common attributes) /&gt;</programlisting>

<para>This rule has no specific attributes.</para>
<para>Use this rule if you know that there can be several whitespaces ahead,
for example in the beginning of indented lines. This rule will skip all
whitespace at once, instead of testing multiple rules and skipping one at a
time due to no match.</para>
</listitem>
</varlistentry>


<varlistentry>
<term>DetectIdentifier</term>
<listitem>
<para>Detect identifier strings (as a regular expression: [a-zA-Z_][a-zA-Z0-9_]*).</para>
<programlisting>&lt;DetectIdentifier (common attributes) /&gt;</programlisting>

<para>This rule has no specific attributes.</para>
<para>Use this rule to skip a string of word characters at once, rather than
testing with multiple rules and skipping one at a time due to no match.</para>
</listitem>
</varlistentry>

</variablelist>
</sect3>

<sect3>
<title>Tips &amp; Tricks</title>

<itemizedlist>
<para>Once you have understood how the context switching works it will be
easy to write highlight definitions. Though you should carefully check what
rule you choose in what situation. Regular expressions are very mighty, but
they are slow compared to the other rules. So you may consider the following
tips.
</para>

<listitem>
<para>If you only match two characters use <userinput>Detect2Chars</userinput>
instead of <userinput>StringDetect</userinput>. The same applies to
<userinput>DetectChar</userinput>.</para>
</listitem>
<listitem>
<para>Regular expressions are easy to use but often there is another much
faster way to achieve the same result. Consider you only want to match
the character <userinput>'#'</userinput> if it is the first character in the
line. A regular expression based solution would look like this:
<programlisting>&lt;RegExpr attribute=&quot;Macro&quot; context=&quot;macro&quot; String=&quot;^\s*#&quot; /&gt;</programlisting>
You can achieve the same much faster in using:
<programlisting>&lt;DetectChar attribute=&quot;Macro&quot; context=&quot;macro&quot; char=&quot;#&quot; firstNonSpace=&quot;true&quot; /&gt;</programlisting>
If you want to match the regular expression <userinput>'^#'</userinput> you
can still use <userinput>DetectChar</userinput> with the attribute <userinput>column=&quot;0&quot;</userinput>.
The attribute <userinput>column</userinput> counts characters, so a tabulator is only one character.
</para>
</listitem>
<listitem>
<para>You can switch contexts without processing characters. Assume that you
want to switch context when you meet the string <userinput>*/</userinput>, but
need to process that string in the next context. The below rule will match, and
the <userinput>lookAhead</userinput> attribute will cause the highlighter to
keep the matched string for the next context.
<programlisting>&lt;Detect2Chars attribute=&quot;Comment&quot; context=&quot;#pop&quot; char=&quot;*&quot; char1=&quot;/&quot; lookAhead=&quot;true&quot; /&gt;</programlisting>
</para>
</listitem>
<listitem>
<para>Use <userinput>DetectSpaces</userinput> if you know that many whitespaces occur.</para>
</listitem>
<listitem>
<para>Use <userinput>DetectIdentifier</userinput> instead of the regular expression <userinput>'[a-zA-Z_]\w*'</userinput>.</para>
</listitem>
<listitem>
<para>Use default styles whenever you can. This way the user will find a familiar environment.</para>
</listitem>
<listitem>
<para>Look into other XML-files to see how other people implement tricky rules.</para>
</listitem>
<listitem>
<para>You can validate every XML file by using the command
<command>validatehl.sh language.xsd mySyntax.xml</command>.
The files <filename>validatehl.sh</filename> and <filename>language.xsd</filename>
are available in <ulink url="https://commits.kde.org/syntax-highlighting?path=data/schema">Syntax
Highlighting repository</ulink>.
</para>
</listitem>
<listitem>
<para>If you repeat complex regular expression very often you can use
<emphasis>ENTITIES</emphasis>. Example:</para>
<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE language SYSTEM "language.dtd"
[
        &lt;!ENTITY myref    "[A-Za-z_:][\w.:_-]*"&gt;
]&gt;
</programlisting>
<para>Now you can use <emphasis>&amp;myref;</emphasis> instead of the regular
expression.</para>
</listitem>
</itemizedlist>
</sect3>

</sect2>

</sect1>


<sect1 id="dev-scripting">
<title>Scripting with JavaScript</title>

<para>
The &kappname; editor component is easily extensible by writing scripts.
The scripting language is ECMAScript (widely known as JavaScript).
&kappname; supports two kinds of scripts: indentation and command line scripts.
</para>

<sect2 id="dev-scripting-indentation">
<title>Indentation Scripts</title>

<para>
Indentation scripts - also referred as indenters - automatically indent the
source code while typing text. As an example, after hitting the return key
the indentation level often increases.
</para>

<para>
The following sections describe step by step how to create the skeleton for a
simple indenter. As a first step, create a new <filename>*.js</filename> file
called &eg; <filename>javascript.js</filename> in the local home folder
<filename>$<envar>XDG_DATA_HOME</envar>/katepart5/script/indentation</filename>.
Therein, the environment variable <envar>XDG_DATA_HOME</envar> typically expands to
either <filename>~/.local</filename> or <filename>~/.local/share</filename>.
</para>
<para>On &Windows; these files are located in <filename>%USER%\AppData\Local\katepart5\indentation</filename>.
<replaceable>%USERPROFILE%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.</para>

<sect3 id="dev-scripting-indentation-header">
<title>The Indentation Script Header</title>
<para>
The header of the file <filename>javascript.js</filename> is embedded as JSON at the beginning of the document as follows:

<programlisting>
var katescript = {
    "name": "JavaScript",
    "author": "Example Name &lt;example.name@some.address.org&gt;",
    "license": "BSD License",
    "revision": 1,
    "kate-version": "5.1",
    "required-syntax-style": "javascript",
    "indent-languages": ["javascript"],
    "priority": 0,
}; // kate-script-header, must be at the start of the file without comments
</programlisting>

Each entry is explained in detail now:
<itemizedlist>
<listitem><para>
<literal>name</literal> [required]: This is the indenter name that appears in the menu
<menuchoice><guimenu>Tools</guimenu><guimenuitem>Indentation</guimenuitem></menuchoice>
and in the configuration dialog.
</para></listitem>
<listitem><para>
<literal>author</literal> [optional]: The author's name and contact information.
</para></listitem>
<listitem><para>
<literal>license</literal> [optional]: Short form of the license, such as BSD License or LGPLv3.
</para></listitem>
<listitem><para>
<literal>revision</literal> [required]: The revision of the script. This number should be increased whenever the script is modified.
</para></listitem>
<listitem><para>
<literal>kate-version</literal> [required]: Minimum required &kappname; version.
</para></listitem>
<listitem><para>
<literal>required-syntax-style</literal> [optional]: The required syntax style, which matches the specified <literal>style</literal> in syntax highlighting files. This is important for indenters that rely on specific highlight information in the document. If a required syntax style is specified, the indenter is available only when the appropriate highlighter is active. This prevents <quote>undefined behavior</quote> caused by using the indenter without the expected highlighting schema. For instance, the Ruby indenter makes use of this in the files <filename>ruby.js</filename> and <filename>ruby.xml</filename>.
</para></listitem>
<listitem><para>
<literal>indent-languages</literal> [optional]: JSON array of syntax styles the indenter can indent correctly, &eg;: <literal>["c++", "java"]</literal>.
</para></listitem>
<listitem><para>
<literal>priority</literal> [optional]: If several indenters are suited for a certain highlighted file, the priority decides which indenter is chosen as default indenter.
</para></listitem>
</itemizedlist>
</para>

</sect3>

<sect3 id="dev-scripting-indentation-body">
<title>The Indenter Source Code</title>
<para>
Having specified the header this section explains how the indentation scripting
itself works. The basic skeleton of the body looks like this:

<programlisting>
// required katepart js libraries, e.g. range.js if you use Range
require ("range.js");
  
triggerCharacters = "{}/:;";
function indent(line, indentWidth, ch)
{
    // called for each newline (ch == '\n') and all characters specified in
    // the global variable triggerCharacters. When calling <menuchoice><guimenu>Tools</guimenu><guimenuitem>Align</guimenuitem></menuchoice>
    // the variable ch is empty, i.e. ch == ''.
    //
    // see also: Scripting API
    return -2;
}
</programlisting>

The function <function>indent()</function> has three parameters:
<itemizedlist>
<listitem><para><literal>line</literal>: the line that has to be indented</para></listitem>
<listitem><para><literal>indentWidth</literal>: the indentation width in number of spaces</para></listitem>
<listitem><para><literal>ch</literal>: either a newline character (<literal>ch == '\n'</literal>), the trigger character specified in <literal>triggerCharacters</literal> or empty if the user invoked the action <menuchoice><guimenu>Tools</guimenu><guimenuitem>Align</guimenuitem></menuchoice>.</para></listitem>
</itemizedlist>
The return value of the <function>indent()</function> function specifies how
the line will be indented. If the return value is a simple integer number, it
is interpreted as follows:
<itemizedlist>
<listitem><para>return value <literal>-2</literal>: do nothing</para></listitem>
<listitem><para>return value <literal>-1</literal>: keep indentation (searches for previous non-blank line)</para></listitem>
<listitem><para>return value <literal> 0</literal>: numbers &gt;= 0 specify the indentation depth in spaces</para></listitem>
</itemizedlist>
Alternatively, an array of two elements can be returned:
<itemizedlist>
<listitem><para><literal>return [ indent, align ];</literal></para></listitem>
</itemizedlist>
In this case, the first element is the indentation depth as above with the
same meaning of the special values. However, the second element is an absolute
value representing a column for <quote>alignment</quote>. If this value is higher than the
indent value, the difference represents a number of spaces to be added after
the indentation of the first parameter. Otherwise, the second number is ignored.
Using tabs and spaces for indentation is often referred to as <quote>mixed mode</quote>.
</para>

<para>
Consider the following example: Assume using tabs to indent, and tab width is set
to 4. Here, &lt;tab&gt; represents a tab and '.' a space:
<programlisting>
1: &lt;tab&gt;&lt;tab&gt;foobar("hello",
2: &lt;tab&gt;&lt;tab&gt;......."world");
</programlisting>
When indenting line 2, the <function>indent()</function> function returns [8, 15]. As result, two
tabs are inserted to indent to column 8, and 7 spaces are added to align the
second parameter under the first, so that it stays aligned if the file is viewed
with a different tab width.
</para>

<para>
A default &kde; installation ships &kappname; with several indenters. The
corresponding JavaScript source code can be found in <filename>$<envar>XDG_DATA_DIRS</envar>/katepart5/script/indentation</filename>.</para>
<para>On &Windows; these files are located in <filename>%USER%\AppData\Local\katepart5\indentation</filename>.
<replaceable>%USER%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.
</para>

<para>
Developing an indenter requires reloading the scripts to see whether the changes
behave appropriately. Instead of restarting the application, simply switch to
the command line and invoke the command <command>reload-scripts</command>.
</para>

<para>
If you develop useful scripts please consider contributing to the &kappname; Project
by <ulink url="mailto:kwrite-devel@kde.org">contacting the mailing list</ulink>.
</para>

</sect3>
</sect2>

<sect2 id="dev-scripting-command-line">
<title>Command Line Scripts</title>

<para>
As it is hard to satisfy everyone's needs, &kappname; supports little helper tools
for quick text manipulation through the
<link linkend="advanced-editing-tools-commandline">built-in command line</link>.
For instance, the command
<command>sort</command> is implemented as a script. This section explains how to create
<filename>*.js</filename> files to extend &kappname; with arbitrary helper scripts.
</para>

<para>
Command line scripts are located in the same folder as indentation scripts.
So as a first step, create a new <filename>*.js</filename> file called
<filename>myutils.js</filename> in the local home folder
<filename>$<envar>XDG_DATA_HOME</envar>/katepart5/script/commands</filename>.
Therein, the environment variable <envar>XDG_DATA_HOME</envar> typically expands to
either <filename>~/.local</filename> or <filename>~/.local/share</filename>.</para>
<para>On &Windows; these files are located in <filename>%USER%\AppData\Local\katepart5\commands</filename>.
<replaceable>%USER%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.
</para>

<sect3 id="dev-scripting-command-line-header">
<title>The Command Line Script Header</title>
<para>
The header of each command line script is embedded in JSON at the beginning of the script as follows:

<programlisting>
var katescript = {
    "author": "Example Name &lt;example.name@some.address.org&gt;",
    "license": "LGPLv2+",
    "revision": 1,
    "kate-version": "5.1",
    "functions": ["sort", "moveLinesDown"],
    "actions": [
        {   "function": "sort",
            "name": "Sort Selected Text",
            "category": "Editing",
            "interactive": "false"
        },
        {   "function": "moveLinesDown",
            "name": "Move Lines Down",
            "category": "Editing",
            "shortcut": "Ctrl+Shift+Down",
            "interactive": "false"
        }
    ]
}; // kate-script-header, must be at the start of the file without comments
</programlisting>

Each entry is explained in detail now:
<itemizedlist>
<listitem><para><literal>author</literal> [optional]: The author's name and contact information.</para></listitem>
<listitem><para><literal>license</literal> [optional]: Short form of the license, such as BSD License or LGPLv2.</para></listitem>
<listitem><para><literal>revision</literal> [required]: The revision of the script. This number should be increased whenever the script is modified.</para></listitem>
<listitem><para><literal>kate-version</literal> [required]: Minimum required &kappname; version.</para></listitem>
<listitem><para><literal>functions</literal> [required]: JSON array of commands in the script.</para></listitem>
<listitem><para><literal>actions</literal> [optional]: JSON Array of JSON objects that defines the actions that appear in the application menu. Detailed information is provided in the section <link linkend="advanced-editing-tools-commandline">Binding Shortcuts</link>.</para></listitem>
</itemizedlist>
</para>

<para>
Since the value of <literal>functions</literal> is a JSON array, a single script is able to contain an arbitrary number
of command line commands. Each function is available through &kappname;'s
<link linkend="advanced-editing-tools-commandline">built-in command line</link>.
</para>
</sect3>

<sect3 id="dev-scripting-command-line-body">
<title>The Script Source Code</title>

<para>
All functions specified in the header have to be implemented in the script.
For instance, the script file from the example above needs to implement the two
functions <command>sort</command> and <command>moveLinesDown</command>.
All functions have the following syntax:

<programlisting>
// required katepart js libraries, e.g. range.js if you use Range
require ("range.js");

function &lt;name&gt;(arg1, arg2, ...)
{
    // ... implementation, see also: Scripting API
}
</programlisting>
</para>

<para>
Arguments in the command line are passed to the function as
<parameter>arg1</parameter>, <parameter>arg2</parameter>, etc.
In order to provide documentation for each command, simply implement the
'<function>help</function>' function as follows:

<programlisting>
function help(cmd)
{
    if (cmd == "sort") {
        return i18n("Sort the selected text.");
    } else if (cmd == "...") {
        // ...
    }
}
</programlisting>

Executing <command>help sort</command> in the command line then calls this help function with
the argument <parameter>cmd</parameter> set to the given command, &ie;
<parameter>cmd == "sort"</parameter>. &kappname; then presents the returned text as
documentation to the user. Make sure to
<link linkend="dev-scripting-api-i18n">translate the strings</link>.
</para>

<para>
Developing a command line script requires reloading the scripts to see whether
the changes behave appropriately. Instead of restarting the application, simply
switch to the command line and invoke the command <command>reload-scripts</command>.
</para>

<sect4 id="dev-scripting-command-line-shortcuts">
<title>Binding Shortcuts</title>
<para>In order to make the scripts accessible in the application menu and assign shortcuts, the script needs to provide an appropriate
script header. In the above example, both functions <literal>sort</literal> and <literal>moveLinesDown</literal> appear in the menu
due to the following part in the script header:
<programlisting>
var katescript = {
    ...
    "actions": [
        {   "function": "sort",
            "name": "Sort Selected Text",
            "icon": "",
            "category": "Editing",
            "interactive": "false"
        },
        {   "function": "moveLinesDown",
            "name": "Move Lines Down",
            "icon": "",
            "category": "Editing",
            "shortcut": "Ctrl+Shift+Down",
            "interactive": "false"
        }
    ]
};
</programlisting>
The fields for one action are as follows:
<itemizedlist>
<listitem><para><literal>function</literal> [required]: The function that should appear in the menu <menuchoice><guimenu>Tools</guimenu> <guisubmenu>Scripts</guisubmenu></menuchoice>.</para></listitem>
<listitem><para><literal>name</literal> [required]: The text appears in the script menu.</para></listitem>
<listitem><para><literal>icon</literal> [optional]: The icon appears next to the text in the menu. All &kde; icon names can be used here.</para></listitem>
<listitem><para><literal>category</literal> [optional]: If a category is specified, the script appears in a submenu.</para></listitem>
<listitem><para><literal>shortcut</literal> [optional]: The shortcut given here is the default shortcut. Example: <literal>Ctrl+Alt+t</literal>. See the <ulink url="http://qt-project.org/doc/qt-5/qt.html#Key-enum">Qt documentation</ulink> for further details.</para></listitem>
<listitem><para><literal>interactive</literal> [optional]: If the script needs user input in the command line, set this to <literal>true</literal>.</para></listitem>
</itemizedlist>
</para>

<para>
If you develop useful scripts please consider contributing to the &kappname; Project
by <ulink url="mailto:kwrite-devel@kde.org">contacting the mailing list</ulink>.
</para>

</sect4>
</sect3>
</sect2>

<sect2 id="dev-scripting-api">
<title>Scripting API</title>

<para>
The scripting API presented here is available to all scripts, &ie; indentation
scripts and command line commands. 
The <classname>Cursor</classname> and <classname>Range</classname> classes are provided by library files in <filename>$<envar>XDG_DATA_DIRS</envar>/katepart5/libraries</filename>.
If you want to use them in your script, which needs to use some of the <classname>Document</classname> or <classname>View</classname> functions, please include the necessary library by using:

<programlisting>
// required katepart js libraries, e.g. range.js if you use Range
require ("range.js");
</programlisting>
</para>

<para>
To extend the standard scripting API with your own functions and prototypes simply
create a new file in &kde;'s local configuration folder
<filename>$<envar>XDG_DATA_HOME</envar>/katepart5/libraries</filename> and include it into your script using:

<programlisting>
require ("myscriptnamehere.js");
</programlisting>

</para>

<para>On &Windows; these files are located in <filename>%USER%\AppData\Local\katepart5\libraries</filename>.
<replaceable>%USER%</replaceable> usually expands to <filename>C:\\Users\\<replaceable>user</replaceable></filename>.</para>

<para>
To extend existing prototypes like <classname>Cursor</classname> or
<classname>Range</classname>, the recommended way is to
<emphasis>not</emphasis> modify the global <filename>*.js</filename> files.
Instead, change the <classname>Cursor</classname> prototype in JavaScript after the <filename>cursor.js</filename> is included into your
script via <literal>require</literal>.
</para>

<sect3 id="dev-scripting-api-prototypes">
<title>Cursors and Ranges</title>

<para>
As &kappname; is a text editor, all the scripting API is based on cursors and
ranges whenever possible. A Cursor is a simple <literal>(line, column)</literal>
tuple representing a text position in the document. A Range spans text from a
starting cursor position to an ending cursor position. The API is explained in
detail in the next sections.
</para>

<sect4 id="dev-scripting-api-cursors">
<title>The Cursor Prototype</title>

<variablelist><varlistentry>
<term><synopsis>
Cursor();
</synopsis></term>
<listitem><para>
Constructor. Returns a Cursor at position <literal>(0, 0)</literal>.</para>
<para>Example: <function>var cursor = new Cursor();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Returns a Cursor at position (line, column).
</para>
<para>Example: <function>var cursor = new Cursor(3, 42);</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Copy constructor. Returns a copy of the cursor <replaceable>other</replaceable>.
</para>
<para>Example: <function>var copy = new Cursor(other);</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor Cursor.clone();
</synopsis></term>
<listitem><para>
Returns a clone of the cursor.</para>
<para>Example: <function>var clone = cursor.clone();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor.setPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Sets the cursor position to <replaceable>line</replaceable> and <replaceable>column</replaceable>.</para>
<para>
Since: &kde; 4.11
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Cursor.isValid();
</synopsis></term>
<listitem><para>
Check whether the cursor is valid. The cursor is invalid, if line and/or
column are set to <literal>-1</literal>.
</para>
<para>
Example: <function>var valid = cursor.isValid();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor Cursor.invalid();
</synopsis></term>
<listitem><para>
Returns a new invalid cursor located at <literal>(-1, -1)</literal>.
</para>
<para>Example: <function>var invalidCursor = cursor.invalid();</function>
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
int Cursor.compareTo(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Compares this cursor to the cursor <replaceable>other</replaceable>. Returns
<itemizedlist>
<listitem><para><literal>-1</literal>, if this cursor is located before the cursor <replaceable>other</replaceable>,</para></listitem>
<listitem><para><literal>0</literal>, if both cursors equal and</para></listitem>
<listitem><para><literal>+1</literal>, if this cursor is located after the cursor <replaceable>other</replaceable>.</para></listitem>
</itemizedlist>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Cursor.equals(<parameter>Cursor <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this cursor and the cursor <replaceable>other</replaceable> are
equal, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String Cursor.toString();
</synopsis></term>
<listitem><para>
Returns the cursor as a string of the form <quote><literal>Cursor(line, column)</literal></quote>.
</para></listitem>
</varlistentry></variablelist>

</sect4>


<sect4 id="dev-scripting-api-ranges">
<title>The Range Prototype</title>

<variablelist><varlistentry>
<term><synopsis>
Range();
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range()</literal> returns a Range at (0, 0) - (0, 0).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range(<parameter>Cursor <replaceable>start</replaceable></parameter>, <parameter>Cursor <replaceable>end</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range(<replaceable>start</replaceable>, <replaceable>end</replaceable>)</literal> returns the Range (<replaceable>start</replaceable>, <replaceable>end</replaceable>).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>int <replaceable>startColumn</replaceable></parameter>, <parameter>int <replaceable>endLine</replaceable></parameter>, <parameter>int <replaceable>endColumn</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Constructor. Calling <literal>new Range(<replaceable>startLine</replaceable>, <replaceable>startColumn</replaceable>, <replaceable>endLine</replaceable>, <replaceable>endColumn</replaceable>)</literal>
returns the Range from (<replaceable>startLine</replaceable>, <replaceable>startColumn</replaceable>) to (<replaceable>endLine</replaceable>, <replaceable>endColumn</replaceable>).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Copy constructor. Returns a copy of Range <replaceable>other</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range Range.clone();
</synopsis></term>
<listitem><para>
Returns a clone of the range.
</para>
<para>Example: <function>var clone = range.clone();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.isEmpty();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the start and end cursors are equal.
</para>
<para>Example: <function>var empty = range.isEmpty();</function>
</para>
<para>
Since: &kde; 4.11
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.isValid();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if both start and end cursor are valid, otherwise <literal>false</literal>.
</para>
<para>Example: <function>var valid = range.isValid();</function>
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range Range.invalid();
</synopsis></term>
<listitem><para>
Returns the Range from (-1, -1) to (-1, -1).
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.contains(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range contains the cursor position, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.contains(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range contains the Range <replaceable>other</replaceable>,
otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.containsColumn(<parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>column</replaceable> is in the half open interval
<literal>[start.column, end.column)</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.containsLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>line</replaceable> is in the half open interval
<literal>[start.line, end.line)</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.overlaps(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range and the range <replaceable>other</replaceable> share
a common region, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.overlapsLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>line</replaceable> is in the interval
<literal>[start.line, end.line]</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.overlapsColumn(<parameter>int <replaceable>column</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if <replaceable>column</replaceable> is in the interval
<literal>[start.column, end.column]</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.onSingleLine();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the range starts and ends at the same line,
&ie; if <replaceable>Range.start.line == Range.end.line</replaceable>.
</para>
<para>
Since: &kde; 4.9
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool Range.equals(<parameter>Range <replaceable>other</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if this range and the Range <replaceable>other</replaceable> are
equal, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String Range.toString();
</synopsis></term>
<listitem><para>
Returns the range as a string of the form <quote><literal>Range(Cursor(line, column), Cursor(line, column))</literal></quote>.
</para></listitem>
</varlistentry></variablelist>

</sect4>
</sect3>

<sect3 id="dev-scripting-api-global">
<title>Global Functions</title>
<para>This section lists all global functions.</para>


<sect4 id="dev-scripting-api-includes">
<title>Reading &amp; Including Files</title>

<variablelist><varlistentry>
<term><synopsis>
String read(<parameter>String <replaceable>file</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Will search the given <replaceable>file</replaceable> relative to the <literal>katepart/script/files</literal> directory and return its content as a string.
</para></listitem>
</varlistentry></variablelist>

<variablelist><varlistentry>
<term><synopsis>
void require(<parameter>String <replaceable>file</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Will search the given <replaceable>file</replaceable> relative to the <literal>katepart/script/libraries</literal> directory and evaluate it.
<literal>require</literal> is internally guarded against multiple inclusions of the same <replaceable>file</replaceable>.
</para>
<para>
  Since: &kde; 4.10
</para>
</listitem>
</varlistentry></variablelist>

</sect4>

<sect4 id="dev-scripting-api-debug">
<title>Debugging</title>

<variablelist><varlistentry>
<term><synopsis>
void debug(<parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Prints <replaceable>text</replaceable> to <literal>stdout</literal> in the
console launching the application.
</para></listitem>
</varlistentry></variablelist>

</sect4>

<sect4 id="dev-scripting-api-i18n">
<title>Translation</title>

<para>In order to support full localization, there are several functions to translate
strings in scripts, namely <literal>i18n</literal>, <literal>i18nc</literal>,
<literal>i18np</literal> and <literal>i18ncp</literal>. These functions behave
exactly like <ulink url="http://techbase.kde.org/Development/Tutorials/Localization/i18n">
&kde;'s translation functions</ulink>.
</para>

<para>The translation functions translate the wrapped strings through &kde;'s
translation system to the language used in the application. Strings in scripts
being developed in the official &kappname; sources are automatically extracted and
translatable. In other words, as a &kappname; developer you do not have to bother with
message extraction and translation. It should be noted though, that the translation
only works inside the &kde; infrastructure, &ie;, new strings in 3rd-party
scripts developed outside of &kde; are not translated.
Therefore, please consider contributing your scripts to &kate; such that
proper translation is possible.
</para>

<variablelist><varlistentry>
<term><synopsis>
void i18n(<parameter>String <replaceable>text</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates <replaceable>text</replaceable> into the language used by the application.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, etc.</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void i18nc(<parameter>String <replaceable>context</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates <replaceable>text</replaceable> into the language used by the
application. Additionally, the string <replaceable>context</replaceable> is
visible to translators so they can provide a better translation.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, etc.</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void i18np(<parameter>String <replaceable>singular</replaceable></parameter>, <parameter>String <replaceable>plural</replaceable></parameter>, <parameter>int <replaceable>number</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates either <replaceable>singular</replaceable> or
<replaceable>plural</replaceable> into the language used by the application,
depending on the given <replaceable>number</replaceable>.
The arguments <replaceable>arg1</replaceable>, ..., are optional and used to
replace the placeholders <literal>%1</literal>, <literal>%2</literal>, etc.</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
void i18ncp(<parameter>String <replaceable>context</replaceable></parameter>, <parameter>String <replaceable>singular</replaceable></parameter>, <parameter>String <replaceable>plural</replaceable></parameter>, <parameter>int <replaceable>number</replaceable></parameter>, <replaceable>arg1</replaceable>, ...);
</synopsis></term>
<listitem><para>
Translates either <replaceable>singular</replaceable> or
<replaceable>plural</replaceable> into the language used by the application,
depending on the given <replaceable>number</replaceable>. Additionally, the
string <replaceable>context</replaceable> is visible to translators so they
can provide a better translation. The arguments <replaceable>arg1</replaceable>,
..., are optional and used to replace the placeholders <literal>%1</literal>,
<literal>%2</literal>, etc.</para></listitem>
</varlistentry></variablelist>

</sect4>
</sect3>

<sect3 id="dev-scripting-api-view">
<title>The View API</title>
<para>Whenever a script is being executed, there is a global variable
<quote><literal>view</literal></quote> representing the current active editor
view. The following is a list of all available View functions.

<variablelist><varlistentry>
<term><synopsis>
<function>Cursor view.cursorPosition()</function>
</synopsis></term>
<listitem><para>Returns the current cursor position in the view.</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.setCursorPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
void view.setCursorPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the current cursor position to either (line, column) or to the given cursor.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor view.virtualCursorPosition();
</synopsis></term>
<listitem><para>
Returns the virtual cursor position with each tab counting the corresponding amount of spaces depending on the current tab width.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.setVirtualCursorPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
void view.setVirtualCursorPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the current virtual cursor position to (line, column) or to the given cursor.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String view.selectedText();
</synopsis></term>
<listitem><para>
Returns the selected text. If no text is selected, the returned string is empty.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool view.hasSelection();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the view has selected text, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range view.selection();
</synopsis></term>
<listitem><para>
Returns the selected text range. The returned range is invalid if there is no
selected text.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.setSelection(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Set the selected text to the given range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.removeSelectedText();
</synopsis></term>
<listitem><para>
Remove the selected text. If the view does not have any selected text, this
does nothing.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.selectAll();
</synopsis></term>
<listitem><para>
Selects the entire text in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void view.clearSelection();
</synopsis></term>
<listitem><para>
Clears the text selection without removing the text.
</para></listitem>
</varlistentry></variablelist>
</para>
</sect3>

<sect3 id="dev-scripting-api-document">
<title>The Document API</title>
<para>
Whenever a script is being executed, there is a global variable
<quote><literal>document</literal></quote> representing the current active
document. The following is a list of all available Document functions.

<variablelist><varlistentry>
<term><synopsis>
String document.fileName();
</synopsis></term>
<listitem><para>
Returns the document's filename or an empty string for unsaved text buffers.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.url();
</synopsis></term>
<listitem><para>
Returns the document's full url or an empty string for unsaved text buffers.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.mimeType();
</synopsis></term>
<listitem><para>
Returns the document's mime type or the mime type <literal>application/octet-stream</literal>
if no appropriate mime type could be found.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.encoding();
</synopsis></term>
<listitem><para>
Returns the currently used encoding to save the file.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
String document.highlightingMode();
</synopsis></term>
<listitem><para>
Returns the global highlighting mode used for the whole document.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
String document.highlightingModeAt(<parameter>Cursor <replaceable>pos</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Returns the highlighting mode used at the given position in the document.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
Array document.embeddedHighlightingModes();
</synopsis></term>
<listitem><para>
Returns an array of highlighting modes embedded in this document.
</para></listitem>
</varlistentry>

<varlistentry>
<term><synopsis>
bool document.isModified();
</synopsis></term>
<listitem><para>
Returns <literal>true</literal>, if the document has unsaved changes (modified), otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.text();
</synopsis></term>
<listitem><para>
Returns the entire content of the document in a single text string. Newlines
are marked with the newline character <quote><literal>\n</literal></quote>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.text(<parameter>int <replaceable>fromLine</replaceable></parameter>, <parameter>int <replaceable>fromColumn</replaceable></parameter>, <parameter>int <replaceable>toLine</replaceable></parameter>, <parameter>int <replaceable>toColumn</replaceable></parameter>);
String document.text(<parameter>Cursor <replaceable>from</replaceable></parameter>, <parameter>Cursor <replaceable>to</replaceable></parameter>);
String document.text(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the text in the given range. It is recommended to use the cursor
    and range based version for better readability of the source code.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.line(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the given text line as string. The string is empty if the requested
    line is out of range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.wordAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.wordAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the word at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term>
<synopsis>
Range document.wordRangeAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
Range document.wordRangeAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis>
</term>
<listitem><para>
Return the range of the word at the given cursor position. The returned range
is invalid (see Range.isValid()), if the text position is after the end of a
line. If there is no word at the given cursor, an empty range is returned.
</para>
<para>
  Since: &kde; 4.9
</para>
</listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.charAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.charAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the character at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.firstChar(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the first character in the given <replaceable>line</replaceable>
    that is not a whitespace. The first character is at column 0. If the line
    is empty or only contains whitespace characters, the returned string is
    empty.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.lastChar(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the last character in the given <replaceable>line</replaceable>
    that is not a whitespace. If the line is empty or only contains whitespace
    characters, the returned string is empty.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isSpace(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isSpace(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the character at the given cursor position is a whitespace,
    otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.matchesAt(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
bool document.matchesAt(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>text</replaceable> matches at the
    corresponding cursor position, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.startsWith(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>bool <replaceable>skipWhiteSpaces</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the line starts with <replaceable>text</replaceable>, otherwise <literal>false</literal>.
    The argument <replaceable>skipWhiteSpaces</replaceable> controls whether leading whitespaces are ignored.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.endsWith(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>bool <replaceable>skipWhiteSpaces</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the line ends with <replaceable>text</replaceable>, otherwise <literal>false</literal>.
    The argument <replaceable>skipWhiteSpaces</replaceable> controls whether trailing whitespaces are ignored.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.setText(<parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Sets the entire document text.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.clear();
</synopsis></term>
<listitem><para>
    Removes the entire text in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.truncate(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.truncate(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Truncate the given line at the given column or cursor position. Returns <literal>true</literal>
    on success, or <literal>false</literal> if the given line is not part of the document range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.insertText(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
bool document.insertText(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Inserts the <replaceable>text</replaceable> at the given cursor position.
    Returns <literal>true</literal> on success, or <literal>false</literal>, if the document is in read-only mode.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.removeText(<parameter>int <replaceable>fromLine</replaceable></parameter>, <parameter>int <replaceable>fromColumn</replaceable></parameter>, <parameter>int <replaceable>toLine</replaceable></parameter>, <parameter>int <replaceable>toColumn</replaceable></parameter>);
bool document.removeText(<parameter>Cursor <replaceable>from</replaceable></parameter>, <parameter>Cursor <replaceable>to</replaceable></parameter>);
bool document.removeText(<parameter>Range <replaceable>range</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Removes the text in the given range. Returns <literal>true</literal> on success, or <literal>false</literal>, if
    the document is in read-only mode.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.insertLine(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Inserts text in the given line. Returns <literal>true</literal> on success, or <literal>false</literal>, if the
    document is in read-only mode or the line is not in the document range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.removeLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Removes the given text line. Returns <literal>true</literal> on success, or <literal>false</literal>, if the
    document is in read-only mode or the line is not in the document range.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.wrapLine(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.wrapLine(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
Wraps the line at the given cursor position. Returns <literal>true</literal> on success,
otherwise <literal>false</literal>, &eg; if line &lt; 0.
</para>
<para>
  Since: &kde; 4.9
</para>
</listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.joinLines(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>int <replaceable>endLine</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Joins the lines from <replaceable>startLine</replaceable> to <replaceable>endLine</replaceable>.
    Two succeeding text lines are always separated with a single space.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lines();
</synopsis></term>
<listitem><para>
    Returns the number of lines in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isLineModified(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if <replaceable>line</replaceable> currently contains unsaved data.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isLineSaved(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if <replaceable>line</replaceable> was changed, but the document was saved.
    Hence, the line currently does not contain any unsaved data.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isLineTouched(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if <replaceable>line</replaceable> currently contains unsaved data or was changed before.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.findTouchedLine(<parameter>int <replaceable>startLine</replaceable></parameter>, <parameter>bool <replaceable>down</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Search for the next touched line starting at <replaceable>line</replaceable>.
    The search is performed either upwards or downwards depending on the search direction specified in <replaceable>down</replaceable>.
</para>
<para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.length();
</synopsis></term>
<listitem><para>
    Returns the number of characters in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lineLength(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the <replaceable>line</replaceable>'s length.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.editBegin();
</synopsis></term>
<listitem><para>
    Starts an edit group for undo/redo grouping. Make sure to always call
    <function>editEnd()</function> as often as you call
    <function>editBegin()</function>. Calling <function>editBegin()</function>
    internally uses a reference counter, &ie;, this call can be nested.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.editEnd();
</synopsis></term>
<listitem><para>
    Ends an edit group. The last call of <function>editEnd()</function> (&ie;
    the one for the first call of <function>editBegin()</function>) finishes
    the edit step.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.firstColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the first non-whitespace column in the given <replaceable>line</replaceable>.
    If there are only whitespaces in the line, the return value is <literal>-1</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lastColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the last non-whitespace column in the given <replaceable>line</replaceable>.
    If there are only whitespaces in the line, the return value is <literal>-1</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.prevNonSpaceColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.prevNonSpaceColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the column with a non-whitespace character starting at the given
    cursor position and searching backwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.nextNonSpaceColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.nextNonSpaceColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the column with a non-whitespace character starting at the given
    cursor position and searching forwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.prevNonEmptyLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the next non-empty line containing non-whitespace characters
    searching backwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.nextNonEmptyLine(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the next non-empty line containing non-whitespace characters
    searching forwards.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isInWord(<parameter>String <replaceable>character</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>character</replaceable> with the
    given <replaceable>attribute</replaceable> can be part of a word, otherwise
    <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.canBreakAt(<parameter>String <replaceable>character</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given <replaceable>character</replaceable> with the given
    <replaceable>attribute</replaceable> is suited to wrap a line, otherwise
    <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.canComment(<parameter>int <replaceable>startAttribute</replaceable></parameter>, <parameter>int <replaceable>endAttribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if a range starting and ending with the given attributes is
    suited to be commented out, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.commentMarker(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for single line comments for a given <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.commentStart(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for the start of multi-line comments for a given
    <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.commentEnd(<parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the comment marker for the end of multi-line comments for a given
    <replaceable>attribute</replaceable>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Range document.documentRange();
</synopsis></term>
<listitem><para>
    Returns a range that encompasses the whole document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor documentEnd();
</synopsis></term>
<listitem><para>
    Returns a cursor positioned at the last column of the last line in the document.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool isValidTextPosition(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool isValidTextPosition(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the given cursor position is positioned at a valid text position.
    A text position is valid only if it locate at the start, in the middle, or the end of a valid line.
    Further, a text position is invalid if it is located in a Unicode surrogate.
</para><para>
    Since: &kde; 5.0
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.attribute(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.attribute(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the attribute at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isAttribute(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
bool document.isAttribute(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute at the given cursor position equals <replaceable>attribute</replaceable>,
    otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.attributeName(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
String document.attributeName(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the attribute name as human readable text. This is equal to the
    <literal>itemData</literal> name in the syntax highlighting files.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isAttributeName(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>name</replaceable></parameter>);
bool document.isAttributeName(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>name</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute name at a certain cursor position matches
    the given <replaceable>name</replaceable>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
String document.variable(<parameter>String <replaceable>key</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the value of the requested document variable <replaceable>key</replaceable>.
    If the document variable does not exist, the return value is an empty string.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
void document.setVariable(<parameter>String <replaceable>key</replaceable></parameter>, <parameter>String <replaceable>value</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Set the value of the requested document variable <replaceable>key</replaceable>.
</para>
<para>
    See also: <link linkend="config-variables">Kate document variables</link>
</para>
<para>
    Since: &kde; 4.8
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.firstVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the virtual column of the first non-whitespace character in the given
    line or <literal>-1</literal>, if the line is empty or contains only whitespace characters.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.lastVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the virtual column of the last non-whitespace character in the given
    line or <literal>-1</literal>, if the line is empty or contains only whitespace characters.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.toVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.toVirtualColumn(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
Cursor document.toVirtualCursor(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Converts the given <quote>real</quote> cursor position to a virtual cursor position,
    either returning an int or a Cursor object.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.fromVirtualColumn(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>virtualColumn</replaceable></parameter>);
int document.fromVirtualColumn(<parameter>Cursor <replaceable>virtualCursor</replaceable></parameter>);
Cursor document.fromVirtualCursor(<parameter>Cursor <replaceable>virtualCursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Converts the given virtual cursor position to a <quote>real</quote> cursor position,
    either returning an int or a Cursor object.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor document.anchor(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>Char <replaceable>character</replaceable></parameter>);
Cursor document.anchor(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>Char <replaceable>character</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Searches backward for the given character starting from the given cursor.
    As an example, if '(' is passed as character, this function will return the
    position of the opening '('. This reference counting, &ie; other '(...)'
    are ignored.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
Cursor document.rfind(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable> = -1</parameter>);
Cursor document.rfind(<parameter>Cursor <replaceable>cursor</replaceable></parameter>, <parameter>String <replaceable>text</replaceable></parameter>, <parameter>int <replaceable>attribute</replaceable> = -1</parameter>);
</synopsis></term>
<listitem><para>
    Find searching backwards the given text with the appropriate <replaceable>attribute</replaceable>.
    The argument <replaceable>attribute</replaceable> is ignored if it is set to
    <literal>-1</literal>. The returned cursor is invalid, if the text could not be found.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
int document.defStyleNum(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
int document.defStyleNum(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns the default style used at the given cursor position.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isCode(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isCode(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute at the given cursor position is not equal
    to all of the following styles: <literal>dsComment</literal>,
    <literal>dsString</literal>, <literal>dsRegionMarker</literal>,
    <literal>dsChar</literal>, <literal>dsOthers</literal>.
</para></listitem>
</varlistentry>



<varlistentry>
<term><synopsis>
bool document.isComment(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isComment(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsComment</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isString(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isString(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsString</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isRegionMarker(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isRegionMarker(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsRegionMarker</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isChar(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isChar(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsChar</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry>


<varlistentry>
<term><synopsis>
bool document.isOthers(<parameter>int <replaceable>line</replaceable></parameter>, <parameter>int <replaceable>column</replaceable></parameter>);
bool document.isOthers(<parameter>Cursor <replaceable>cursor</replaceable></parameter>);
</synopsis></term>
<listitem><para>
    Returns <literal>true</literal>, if the attribute of the character at the cursor position
    is <literal>dsOthers</literal>, otherwise <literal>false</literal>.
</para></listitem>
</varlistentry></variablelist>
</para>

</sect3>
</sect2>

</sect1>

</chapter>
